[{"categories":["Blockchain"],"content":"Una blockchain es una libro de registros de bloques de información que son almacenados secuencialmente y enlazados por métodos criptográficos a través de una red de computadores. Es más que un simple algoritmo, blockchain es una tecnología que facilita la intermediación descentralizada de datos entre los participantes","date":"2022-03-23","objectID":"/20220323solananftandipfs/","tags":["Sistemas distribuidos"],"title":"¿Cómo crear un NFT en Solana con IPFS?","uri":"/20220323solananftandipfs/"},{"categories":["Blockchain"],"content":"Los NFTs son mucho más que images generadas aleatoriamente, esto promete ser la revolución en los títulos de propiedad digital en la web tal y como la conocemos. Si quieres aprender más acerca de esto, te recomiendo leer el articulo de Nick Szabo, Secure Property Titles with Owner Authority, allí encontrarás las primeras ideas acerca de todo este asunto de los NFTs. A continuación vamos a ver cómo crear una colección de NFTs en Solana usando Pinata e IPFS. Este es un tutorial especialmente interesante porque Solana ha estado estrechamente vinculado Arweave, pero muchos proyectos prefieren IPFS por su rápido acceso al contenido y su fiabilidad. Metaplex, es un proyecto construido para hacer más fácil la creación de proyectos NFT en Solana y tiene soporte para IPFS, y esto incluye la capacidad para usar Pinata para almacenar contenido y servir este contenido a través de una puerta de enlace IPFS dedicada. ","date":"2022-03-23","objectID":"/20220323solananftandipfs/:0:0","tags":["Sistemas distribuidos"],"title":"¿Cómo crear un NFT en Solana con IPFS?","uri":"/20220323solananftandipfs/"},{"categories":["Blockchain"],"content":"Configuración del ambiente de trabajo Para empezar, asegúrate de registrarte en Pinata. Usted puede hacer pruebas con una cuenta gratuita, pero para el lanzamiento de NFTs en la red principal, debes considerar el plan professional con una puerta de enlace IPFS dedicada. Una vez que te hayas inscrito en una cuenta, sólo tienes que asegurarte de que tienes instalados los siguientes elementos (cada uno de ellos está vinculado a las instrucciones de instalación en caso de que tengas que instalarlos): Node.js - version 16.13.0 o la más reciente. Git - versión 2.32.0 o la más reciente. Yarn - versión 1.22.17 o la más reciente. ts-node - versión 10.4.0 o la más reciente. Solana CLI - version 1.8.16 o la más reciente. Por si sirve de algo, seguiremos gran parte de las instrucciones de la página web de Metaplex con algunas modificaciones que nos permitan subir contenidos a IPFS a través de Pinata. ","date":"2022-03-23","objectID":"/20220323solananftandipfs/:1:0","tags":["Sistemas distribuidos"],"title":"¿Cómo crear un NFT en Solana con IPFS?","uri":"/20220323solananftandipfs/"},{"categories":["Blockchain"],"content":"Preparando los activos Este tutorial no va a pasar por el proceso de generar los activos para su proyecto de NFTs. Ese es un esfuerzo totalmente separado que tiene que ocurrir antes de que el contrato puede ser desplegado en Solana. Así que, asumiendo que usted ya tiene las imágenes creadas, vamos a ver cómo prepararlas para subirlas a IPFS a través de Metaplex. El primer paso es crear una carpeta para los activos de su proyecto NFT. Desde la línea de comandos, que se verá así: mkdir nft-project Dentro de esa carpeta, crea otra carpeta llamada assets. En la carpeta assets, añadirás todas tus imágenes. Es importante que cada una de tus imágenes esté etiquetada en un formato de índice base 0. Eso significa que la primera imagen sería 0.png y la segunda sería 1.png y así sucesivamente. Una vez que sus imágenes estén en la carpeta, tendrá que crear los metadatos para estas imágenes. Si tiene alguna experiencia con los metadatos NFT de Ethereum, se sentirá como en casa con los metadatos NFT de Solana. La estructura es casi idéntica. Echemos un vistazo a una estructura básica de archivo de metadatos JSON para NFTs en Solana: { \"name\": \"Number #0001\", \"symbol\": \"NB\", \"description\": \"Collection of 10 numbers on the blockchain. This is the number 1/10.\", \"image\": \"0.png\", \"attributes\": [ {\"trait_type\": \"Layer-1\", \"value\": \"0\"}, {\"trait_type\": \"Layer-2\", \"value\": \"0\"}, {\"trait_type\": \"Layer-3\", \"value\": \"0\"}, {\"trait_type\": \"Layer-4\", \"value\": \"1\"} ], \"properties\": { \"creators\": [{\"address\": \"N4f6zftYsuu4yT7icsjLwh4i6pB1zvvKbseHj2NmSQw\", \"share\": 100}], \"files\": [{\"uri\": \"0.png\", \"type\": \"image/png\"}] }, \"collection\": {\"name\": \"numbers\", \"family\": \"numbers\"} } Al igual que con el estándar de metadatos de Ethereum, el estándar de metadatos de Solana tiene un nombre, una imagen y una descripción. Además, se pueden incluir atributos (al igual que con ETH), un símbolo y detalles de cobro. En los proyectos de Ethereum, el símbolo del token se asigna generalmente en la implementación del contrato y no en los metadatos. Otra diferencia es la parte de propiedades de los metadatos de Solana. Esto es necesario y le permite incluir una serie de archivos para sus NFT. Tiene que tener al menos un archivo en esa matriz que apunte al mismo activo que la propiedad de la imagen, pero puede incluir otros archivos que conformen su NFT completa. Este es un concepto realmente interesante que debe ser explorado más a fondo, pero por el bien de este post, sólo vamos a operar con NFTs de un solo activo. Si desea profundizar en la norma de los metadatos de Solana para los NFTs, puede hacerlo aquí. Ahora que tenemos las imágenes en la carpeta. Sabemos que esas imágenes necesitan ser nombradas de una manera específica. Y sabemos que necesitamos archivos de metadatos JSON. ¿Cómo vamos a conseguir ahora esos archivos JSON creados y añadidos a la carpeta de activos. Podrías hacerlo manualmente, pero con un proyecto de 10.000 NFT, eso sería casi imposible. Vamos a escribir un script para crear los archivos de metadatos. Desde tu línea de comandos, asegúrate de que estás en la carpeta nft-project. Crearemos un nuevo archivo llamado metadata-generator.js ejecutando este comando: touch metadata-generator.js. En tu editor de código, abre ese nuevo archivo. Está vacío, pero lo rellenaremos ahora. Tenemos que recorrer todas las imágenes en nuestra carpeta de activos y crear un único archivo JSON para cada uno. Necesitamos nombrar y guardar ese archivo JSON en la misma carpeta de activos. Para hacer esto, haremos uso del Node.js fs que está incorporado en Node.js. En su archivo metadata-generator.js añada este código: const fs = require('fs'); const imageDir = fs.readdirSync(\"./assets\"); imageDir.forEach(img =\u003e { const metadata = { name: `Image ${img.split(\".\")[0]}`, description: \"An image in the NFT collection\", symbol: \"YOUR_NFT_COLLECTION_SHORT_SYMBOL\", image: img, seller_fee_basis_points: \"ROYALTIES_PERCENTAGE_BASIS_POINTS\", properties: { files: [{ uri: img, \"type\": \"im","date":"2022-03-23","objectID":"/20220323solananftandipfs/:2:0","tags":["Sistemas distribuidos"],"title":"¿Cómo crear un NFT en Solana con IPFS?","uri":"/20220323solananftandipfs/"},{"categories":["Blockchain"],"content":"Metaplex Metaplex es una herramienta que facilita el lanzamiento de un proyecto NFT en Solana. En lugar de tener que escribir tu propio contrato inteligente como tendrías que hacer con Ethereum, Metaplex tiene contratos pre-escritos que los proyectos pueden conectar. Para que esto funcione, Metaplex tiene que ser capaz de acceder a los archivos asociados a los NFTs, luego tiene que ser capaz de subir esos archivos y asociarlos a cada token que se va a acuñar. Metaplex tiene soporte para IPFS a través de algunos servicios, pero nos centraremos en el uso de Pinata. Vamos a seguir la guía estándar de Metaplex Candy Machine que se encuentra aquí. El primer paso va a ser clonar Metaplex. Ejecute el siguiente comando en su terminal: git clone https://github.com/metaplex-foundation/metaplex.git ~/metaplex Estamos clonando el directorio en el directorio home para que no tengamos que recordar dónde se clonó el proyecto. Dentro del nuevo repositorio de metaplex hay un código para soportar la CLI de JavaScript que vamos a utilizar. Por lo tanto, tenemos que instalar las dependencias para ese código CLI. yarn install --cwd ~/metaplex/js/ Ahora, asegurémonos de que la instalación ha funcionado. ¿Recuerdas que instalamos ts-node? Vamos a usar eso ahora para ejecutar un comando para el cli de metaplex export candymachine=«YOUR_ROOT_PATH»/metaplex/js/packages/cli/src/candy-machine-v2-cli.ts ts-node $candymachine --version # Output 0.0.2 Esto debería imprimir una versión si todo fue instalado correctamente. Ahora, necesitamos asegurarnos de que el CLI de Solana está funcionando. Ejecute este comando para obtener el número de versión: solana --version # Output solana-cli 1.8.16 (src:23af37fe; feat:188619054 Si eso funciona, está listo. Si no es así, comprueba que has instalado el Solana CLI Toolkit. A continuación, vamos a utilizar ese CLI para crear la cartera devnet. El devnet de Solana es donde podemos experimentar sin temor a incurrir en ningún impacto financiero real. Ejecute este comando para crear una nueva criptcartera de papel y almacenar las credenciales solana-keygen new --outfile ~/.config/solana/«MY_WALLET_PAPER».json Ahora, podemos establecer el par de claves por defecto para nuestras interacciones de Solana CLI: solana config set --keypair ~/.config/solana/«MY_WALLET_PAPER».json Por último, hagamos saber a la CLI que pretendemos interactuar con la devnet: solana config set --url devnet Pora comprobar la configuración actual de la red (y otras) podemos emplear este comando: solana config get # Output Config File: /home/user/.config/solana/cli/config.yml RPC URL: https://api.devnet.solana.com WebSocket URL: wss://api.devnet.solana.com/ (computed) Keypair Path: /home/user/.config/solana/«MY_PAPER_WALLET».json Commitment: confirmed con el CLI podemos ver la dirección de nuestra criptocartera: solana address # Output is something like this: 4aDSG82CdgMwt81z7AwnLnDRZyp6MjvZMUVpT82HZRU9 A continuación vamos a conseguir algo de token de Solana, para hacer esto, asegurate de que te encuentras en la devnet, ya que nuestra dapp va funcionar en esta red. Para conseguir los tokens hacemos: solana airdrop 2 4aDSG82CdgMwt81z7AwnLnDRZyp6MjvZMUVpT82HZRU9 --url devnet # Output is something like this: Requesting airdrop of 2 SOL Signature: 3KsFBCULmso5Lc7CAQdqF8rzsBXb3xaVrG3cup19n3P2paw3ryvovWQ9MsMB8GMiQkXJWyHXGrni63BsNrxVfHP2 2 SOL Para obtener la información completa de nuestra cuenta: solana account «YOUR_ADDRESS» # Output is something like this: Public Key: 4aDSG82CdgMwt81z7AwnLnDRZyp6MjvZMUVpT82HZRU9 Balance: 4.956381584 SOL Owner: 11111111111111111111111111111111 Executable: false Rent Epoch: 277 Para verificar el balance de nuestro monedero hacemos: solana balance 4aDSG82CdgMwt81z7AwnLnDRZyp6MjvZMUVpT82HZRU9 # Output 2 SOL Hasta aquí hemos conseguido crear una criptocartera de papel y fondear con un 2 SOL, tokens que utilizaremos más adelante para probar nuestra aplicación. A continuación vamos a ver cómo podemos cambiar entre cada una de la","date":"2022-03-23","objectID":"/20220323solananftandipfs/:3:0","tags":["Sistemas distribuidos"],"title":"¿Cómo crear un NFT en Solana con IPFS?","uri":"/20220323solananftandipfs/"},{"categories":["Blockchain"],"content":"Drop configuration ","date":"2022-03-23","objectID":"/20220323solananftandipfs/:4:0","tags":["Sistemas distribuidos"],"title":"¿Cómo crear un NFT en Solana con IPFS?","uri":"/20220323solananftandipfs/"},{"categories":["Blockchain"],"content":"Patrocinio ₿itcoin: Solana: Ethereum: Paypal: alejandro.driveyali@gmail.com ","date":"2022-03-23","objectID":"/20220323solananftandipfs/:5:0","tags":["Sistemas distribuidos"],"title":"¿Cómo crear un NFT en Solana con IPFS?","uri":"/20220323solananftandipfs/"},{"categories":["Blockchain"],"content":"Imágenes Unplash - NTF inscription on cubes against the background of dollars and microcircuits ","date":"2022-03-23","objectID":"/20220323solananftandipfs/:6:0","tags":["Sistemas distribuidos"],"title":"¿Cómo crear un NFT en Solana con IPFS?","uri":"/20220323solananftandipfs/"},{"categories":["Blockchain"],"content":"Referencias Julius Berner. 2021. The Modern Mathematics of deep learning. Yaser Abu-Mostafa Data. 2012 - 2015. Learning From Data. Web3.js Metaboss ","date":"2022-03-23","objectID":"/20220323solananftandipfs/:7:0","tags":["Sistemas distribuidos"],"title":"¿Cómo crear un NFT en Solana con IPFS?","uri":"/20220323solananftandipfs/"},{"categories":["Blockchain"],"content":"Una blockchain es una libro de registros de bloques de información que son almacenados secuencialmente y enlazados por métodos criptográficos a través de una red de computadores. Es más que un simple algoritmo, blockchain es una tecnología que facilita la intermediación descentralizada de datos entre los participantes","date":"2022-03-10","objectID":"/20220310solana/","tags":["Sistemas distribuidos"],"title":"Programando Dapps en Solana","uri":"/20220310solana/"},{"categories":["Blockchain"],"content":"El objetivo de este artículo es introducir el desarrollo de aplicaciones descentralizadas (dapps) en la cadena de bloques de Solana. En principio, vamos a explorar las herramientas que hay disponibles para el trabajo, para luego desarrollar una dapp de ejemplo y entender cómo interactúan todos los elementos del ecosistema de Solana. Espero que el contenido que voy a presentar a continuación sea de su agrado y les permita incrementar su Qi como desarrolladores de Blockchain. ","date":"2022-03-10","objectID":"/20220310solana/:0:0","tags":["Sistemas distribuidos"],"title":"Programando Dapps en Solana","uri":"/20220310solana/"},{"categories":["Blockchain"],"content":"Comunidades de Solana Antes de comenzar es importante señalar que el ecosistema de Solana es relativamente nuevo y está en constante evolución, por esta razón el contenido que se produce acerca de esta tecnología se desactualiza con rapidez. Por lo tanto, una de mis recomendaciones es procurar seguir la documentación oficial de Solana y unirse a las comunidades que desarrollan y participan del proyecto, allí puedes encontrar la solución a muchas de tus preguntas, con solo seguir el hilo de las conversaciones antiguas, además estoy seguro que muchos desarrolladores que participan de estas comunidades son muy amables y están dispuestos a ayudarte en caso de ser necesario. Te dejo algunos de los canales de discord que me ha sido de mucha utilidad: Anchor Stractors Metaplex Solana Tech Y si te interesa, también te dejo mi canal: CODE \u0026 MATH. ","date":"2022-03-10","objectID":"/20220310solana/:1:0","tags":["Sistemas distribuidos"],"title":"Programando Dapps en Solana","uri":"/20220310solana/"},{"categories":["Blockchain"],"content":"Prerequisitos A continuación, enumeraré los herramientas y la respectivas versiones que utilicé al momento de escribir este articulo. En cada uno de los items encontrarás enlazada cada herramienta con la documentación para instalarlas, ya que cada proyecto explica como hacerlo y además de mantienen actualizados los procedimientos: Solana Tool Suite (1.8.16) - Esta es la CLI de Solana. La documentación es muy completa y allí encontrarás todos los detalles para aprender a utilizarla. Anchor (0.21.0) - Seguramente si has desarrollado dapps sobre Ethereum, habrás utilizado Hardhat. Bueno, Anchor es un framework parecido a Hardhat que se utiliza para desarrollar dapps sobre Solana. solana/web3.js (1.36.0) - Es una version de web3.js para solana, sin embargo la documentación no es muy buena, así que si tienes dificultades con ella busca apoyo en las comunidades de discord. React.js (17.0.2) - Framework para el desarrollo de Front-end. Bastante popular y con muy buena documentación. Node.js (16.04) - Para instalarla puedes usar nvm. Phantom - Es la criptocartera que emplearemos para guardar las criptomonedas de Solana. En otro artículo trataré de explicar en que consiste la tecnología Blockchain y cuáles son las características principales de Solana. Por ahora solo nos centraremos en construir un ejemplo que sirva de ilustración para entender cómo desarrollar una dapp sobre Solana. Si quieres aprender más sobre Solana y cómo funciona, aquí hay algunos artículos muy buenos: Documentación oficial de Solana. Solana Summer. ","date":"2022-03-10","objectID":"/20220310solana/:2:0","tags":["Sistemas distribuidos"],"title":"Programando Dapps en Solana","uri":"/20220310solana/"},{"categories":["Blockchain"],"content":"¿Qué vamos a construir? ","date":"2022-03-10","objectID":"/20220310solana/:3:0","tags":["Sistemas distribuidos"],"title":"Programando Dapps en Solana","uri":"/20220310solana/"},{"categories":["Blockchain"],"content":"Solana CLI El CLI de Solana nos permite principalmente configurar nuestra red (entre localhost, testnet, devnet o mainnet-beta) además de obtener algunas criptomonedas en nuestro criptocartera para realizar pruebas. Nota Las criptomonedas de las redes localhost, testnet y devnet no tiene ningún valor comercial, son solo para probar las dapps en ambientes de desarrollo. ","date":"2022-03-10","objectID":"/20220310solana/:4:0","tags":["Sistemas distribuidos"],"title":"Programando Dapps en Solana","uri":"/20220310solana/"},{"categories":["Blockchain"],"content":"Generando un criptocartera de papel Para poder probar nuestro programa de Solana vamos a necesitar una criptocartera. Una criptocartera de criptomonedas almacena colecciones de claves que son utilizadas para enviar y recibir criptomonedas. A continuación vamos a generar un criptocartera de papel usando la línea de comandos de Solana. Para generar una criptocartera de papel, utilizaremos el comando solana-keygen, que se debería haber sido instalado cuando instalamos el CLI de solana. Sin embargo, para verificar que se instaló correctamente, ejecute el siguiente comando: solana --version # Output solana-cli 1.8.16 (src:23af37fe; feat:1886190546) Si ves la versión de solana-keygen, significa que podemos empezar a usarla. Ejecuta el siguiente comando para generar un par de claves: solana-keygen new --outfile ~/.config/solana/«MY_PAPER_WALLET».json # Output Generating a new keypair For added security, enter a BIP39 passphrase NOTE! This passphrase improves security of the recovery seed phrase NOT the keypair file itself, which is stored as insecure plain text BIP39 Passphrase (empty for none): Wrote new keypair to /home/alejandro/.config/solana/«MY_PAPER_WALLET».json ============================================================================== pubkey: A9exxqnew6bbovMLt8ZDA2CyUVEKP6Y2uGkT8EGE2q7J ============================================================================== Save this seed phrase and your BIP39 passphrase to recover your new keypair: surface pride wild second judge where episode wire enforce trial upgrade music Esto generará una frase semilla aleatoria y le pedirá que añada una frase de contraseña opcional. Siéntase libre de añadir una frase de contraseña si lo desea, está bien no hacerlo para los propósitos de este tutorial. Una vez que hayas rellenado la información, el terminal debería mostrar la clave pública y la frase semilla generada. Copie y guarde la frase semilla en un lugar seguro. El par de claves se generará en la siguiente ubicación: /home/\u003cyour user\u003e/.config/solana/«MY_PAPER_WALLET».json Nota El archivo json puede llamarse como usted quiera, asegúrese de recordar que debe almacenar su frase semilla en algún lugar seguro. Para usar tu nueva criptocartera, entonces escribimos el siguiente comando: solana config set --keypair ~/.config/solana/«MY_PAPER_WALLET».json # Output Config File: /home/alejandro/.config/solana/cli/config.yml RPC URL: https://api.devnet.solana.com WebSocket URL: wss://api.devnet.solana.com/ (computed) Keypair Path: /home/alejandro/.config/solana/«MY_PAPER_WALLET».json Commitment: confirmed Ahora vamos a conseguir algunos tokens de prueba, para esto nos aseguramos primero de usar la red de pruebas devnet: solana config set --url devnet # Output Config File: /home/alejandro/.config/solana/cli/config.yml RPC URL: https://api.devnet.solana.com WebSocket URL: wss://api.devnet.solana.com/ (computed) Keypair Path: /home/alejandro/.config/solana/«MY_PAPER_WALLET».json Commitment: confirmed Pora comprobar la configuración actual de la red (y otras) podemos emplear este comando: solana config get # Output Config File: /home/user/.config/solana/cli/config.yml RPC URL: https://api.devnet.solana.com WebSocket URL: wss://api.devnet.solana.com/ (computed) Keypair Path: /home/user/.config/solana/«MY_PAPER_WALLET».json Commitment: confirmed con el CLI podemos ver la dirección de nuestra criptocartera: solana address # Output is something like this: 4aDSG82CdgMwt81z7AwnLnDRZyp6MjvZMUVpT82HZRU9 A continuación vamos a conseguir algo de token de Solana, para hacer esto, asegurate de que te encuentras en la devnet, ya que nuestra dapp va funcionar en esta red. Para conseguir los tokens hacemos: solana airdrop 2 4aDSG82CdgMwt81z7AwnLnDRZyp6MjvZMUVpT82HZRU9 --url devnet # Output is something like this: Requesting airdrop of 2 SOL Signature: 3KsFBCULmso5Lc7CAQdqF8rzsBXb3xaVrG3cup19n3P2paw3ryvovWQ9MsMB8GMiQkXJWyHXGrni63BsNrxVfHP2 2 SOL Para obtener la información completa de nuestra cuenta: solana account «","date":"2022-03-10","objectID":"/20220310solana/:4:1","tags":["Sistemas distribuidos"],"title":"Programando Dapps en Solana","uri":"/20220310solana/"},{"categories":["Blockchain"],"content":"Gestionando las diferentes redes de solana Para utilizar las redes localhost, testnet, devnet o mainnet-beta, podemos hacer lo siguiente: # set to localhost solana config set --url localhost # set to testnet solana config set --url localhost # set config devnet solana config set --url devnet # set config mainnet solana config set --url mainnet # Output Config File: /home/user/.config/solana/cli/config.yml RPC URL: https://api.devnet.solana.com WebSocket URL: wss://api.devnet.solana.com/ (computed) Keypair Path: /home/user/.config/solana/devnet.json Commitment: confirmed Esto es importante estar al tanto de qué red estás usando mientras construyes, pruebas y despliegas tus programas. Asegurate de que tu cirptocartera está usando la misma red que de tu entorno local. Por ejemplo, si vamos a desarrollar nuestra aplicación en la red de devnet, entonces ejecutamos: # set config devnet solana config set --url devnet Si en cambio, deseas trabajar con la red en localhost, primero deberás iniciar el nodo local de Solana para realizar la pruebas: solana-test-validator #Output is something like this: Ledger location: test-ledger Log: test-ledger/validator.log Identity: D2tKzcNv1iLwWpQpEhwSXvuPH5vQUXy8jwCYvGEUzgZv Genesis Hash: 3qied4BanGash7eNA46H3UwnP3VLa96gYnMtDgEdQK3T Version: 1.8.16 Shred Version: 38112 Gossip Address: 127.0.0.1:1024 TPU Address: 127.0.0.1:1027 JSON RPC URL: http://127.0.0.1:8899 ..... Y luego # set config devnet solana config set --url localhost Además de obtener algo de tokens para está red: solana airdrop 2 4aDSG82CdgMwt81z7AwnLnDRZyp6MjvZMUVpT82HZRU9 --url localhost # Output is something like this: Requesting airdrop of 1 SOL Signature: 3KsFBCULmso5Lc7CAQdqF8rzsBXb3xaVrG3cup19n3P2paw3ryvovWQ9MsMB8GMiQkXJWyHXGrni63BsNrxVfHP2 1 SOL Ahora que ya tienes solanas en tu criptocartera, podemos continuar con la siguiente fase de nuestro proyecto. ","date":"2022-03-10","objectID":"/20220310solana/:4:2","tags":["Sistemas distribuidos"],"title":"Programando Dapps en Solana","uri":"/20220310solana/"},{"categories":["Blockchain"],"content":"Configuración inicial de una dapp con Anchor Para iniciar, creamos un nuevo proyecto de Anchor y cambiamos al nuevo directorio: anchor init mydapp --javascript cd mydapp # Output is something like this: yarn install v1.22.17 warning package.json: No license field info No lockfile found. warning No license field [1/4] Resolving packages... warning @project-serum/anchor \u003e @solana/web3.js \u003e rpc-websockets \u003e circular-json@0.5.9: CircularJSON is in maintenance only, flatted is its successor. [2/4] Fetching packages... [3/4] Linking dependencies... warning \" \u003e ts-mocha@8.0.0\" has incorrect peer dependency \"mocha@^3.X.X || ^4.X.X || ^5.X.X || ^6.X.X || ^7.X.X || ^8.X.X\". [4/4] Building fresh packages... success Saved lockfile. Done in 11.66s. mydapp initialized Si deseamos trabajar con Typescript escribimos solamente: anchor init mydapp cd mydapp # Output is something like this: yarn install v1.22.17 warning package.json: No license field info No lockfile found. warning No license field [1/4] Resolving packages... warning @project-serum/anchor \u003e @solana/web3.js \u003e rpc-websockets \u003e circular-json@0.5.9: CircularJSON is in maintenance only, flatted is its successor. [2/4] Fetching packages... [3/4] Linking dependencies... warning \" \u003e ts-mocha@8.0.0\" has incorrect peer dependency \"mocha@^3.X.X || ^4.X.X || ^5.X.X || ^6.X.X || ^7.X.X || ^8.X.X\". [4/4] Building fresh packages... success Saved lockfile. Done in 11.66s. mydapp initialized Como podrás comprobar, este comando creo la siguiente estructura de archivos: tree -L 1 # Output is something like this: . ├── Anchor.toml ├── app ├── Cargo.toml ├── migrations ├── node_modules ├── package.json ├── programs ├── tests ├── tsconfig.json └── yarn.lock 5 directories, 5 files Como se puede apreciar hay cuatro directorios a resaltar: app - Este directorio se utilizará para alojar el frontend de la aplicación. programs - Aquí se alojan los programas codificados en Rust. Estos son los archivos que defines los programas sobre la blockchain de Solana. test - En este directorio de alojan las pruebas para cada unas de las funcionalidades de nuestra dapp. migrations - Contiene todos los scripts necesarios para el despliegue de la dapp. Echemos un vistazo al programa que se creó para nosotros. Anchor utiliza, y nos permite escribir, un eDSL (DSL embebido) que abstrae muchas de las operaciones de bajo nivel más complejas que normalmente tendrías que hacer si estuvieras usando Solana y Rust sin él, haciéndolo más accesible. useanchor_lang::prelude::*;declare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");#[program]pubmod mydapp{usesuper::*;pubfn initialize(ctx: Context\u003cInitialize\u003e)-\u003e ProgramResult{Ok(())}}#[derive(Accounts)]pubstruct Initialize{} Este es probablemente el programa más básico que puedes escribir. Lo único que sucede aquí es que estamos definiendo una función llamada initialize, que cuando se invoca simplemente sale del programa con éxito. No hay ninguna manipulación de datos. La estructura Initialize define el contexto como vacío de cualquier argumento. Aprenderemos más sobre el contexto de la función más adelante. Para compilar este programa, podemos ejecutar el comando Anchor build: anchor build # Output is something like this: BPF SDK: /home/alejandro/.local/share/solana/install/releases/1.8.16/solana-release/bin/sdk/bpf cargo-build-bpf child: rustup toolchain list -v cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release Compiling proc-macro2 v1.0.36 Compiling unicode-xid v0.2.2 Compiling syn v1.0.86 Compiling serde_derive v1.0.136 Compiling serde v1.0.136 Compiling version_check v0.9.4 Compiling typenum v1.15.0 Compiling serde_json v1.0.79 Compiling semver v1.0.6 Compiling anyhow v1.0.56 Compiling ryu v1.0.9 Compiling opaque-debug v0.3.0 Compiling cfg-if v1.0.0 Compiling itoa v1.0.1 Compiling yansi v0.5.0 Compiling cpufeatures v0.2.1 Compiling unicode-segmentation v1.9.0 Compiling bs58 v0.3.1 Compiling subtle v2.4.1 Compiling rustversion v1.0.6 Compiling fe","date":"2022-03-10","objectID":"/20220310solana/:5:0","tags":["Sistemas distribuidos"],"title":"Programando Dapps en Solana","uri":"/20220310solana/"},{"categories":["Blockchain"],"content":"Hello World Ahora que tenemos nuestro proyecto configurado, vamos a crear algo un poco más interesante. Sé que, como desarrollador full stack, la mayoría de las veces me pregunto cómo hacer operaciones del tipo CRUD, así que eso es lo que veremos a continuación. El primer programa que crearemos nos permitirá crear un contador que se incremente cada vez que lo llamemos desde una aplicación cliente. Lo primero que debemos hacer es abrir programs/mysolanaapp/src/lib.rs y actualizarlo con el siguiente código: useanchor_lang::prelude::*;declare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");#[program]mod mydapp{usesuper::*;pubfn create(ctx: Context\u003cCreate\u003e)-\u003e ProgramResult{letbase_account=\u0026mutctx.accounts.base_account;base_account.count=0;Ok(())}pubfn increment(ctx: Context\u003cIncrement\u003e)-\u003e ProgramResult{letbase_account=\u0026mutctx.accounts.base_account;base_account.count+=1;Ok(())}}// Transaction instructions #[derive(Accounts)]pubstruct Create\u003c'info\u003e{#[account(init, payer = user, space = 16 + 16)]pubbase_account: Account\u003c'info,BaseAccount\u003e,#[account(mut)]pubuser: Signer\u003c'info\u003e,pubsystem_program: Program\u003c'info,System\u003e,}// Transaction instructions #[derive(Accounts)]pubstruct Increment\u003c'info\u003e{#[account(mut)]pubbase_account: Account\u003c'info,BaseAccount\u003e,}// An account that goes inside a transaction instruction #[account]pubstruct BaseAccount{pubcount: u64,} Nota Recuerda que si estás usando Anchor 0.22.0 o superior debes remplazar ProgramResult por Result\u003c()\u003e. En este programa tenemos dos funciones - create e increment. Estas dos funciones son los manejadores de peticiones RPC que podremos llamar desde una aplicación cliente para interactuar con el programa. El primer parámetro de un manejador RPC es la estructura Context, que describe el contexto que se pasará cuando se llame a la función y cómo manejarlo. En el caso de Create, se esperan tres parámetros: base_account, user, y system_program. Los atributos #[account(…)] definen las restricciones e instrucciones que están relacionadas con la cuenta de origen donde se declara. Si alguna de estas restricciones no se mantiene, entonces la instrucción nunca se ejecutará. Cualquier cliente que llame a este programa con la base_account adecuada puede llamar a estos métodos RPC. La forma en que Solana maneja los datos es muy diferente a cualquier cosa con la que haya trabajado. No hay un estado persistente dentro del programa, todo se adjunta a lo que se conoce como cuentas. Una cuenta contiene esencialmente todo el estado de un programa. Debido a esto, todos los datos se pasan por referencia desde el exterior. Tampoco hay operaciones de lectura. Esto se debe a que todo lo que necesitas hacer para leer el contenido de un programa es solicitar la cuenta, a partir de ahí eres capaz de ver todo el estado del programa. Para leer más sobre el funcionamiento de las cuentas, consulta este post. Para construir el programa: anchor build # Output is something like this: BPF SDK: /home/alejandro/.local/share/solana/install/releases/1.8.16/solana-release/bin/sdk/bpf cargo-build-bpf child: rustup toolchain list -v cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release Compiling mydapp2 v0.1.0 (/home/alejandro/Documentos/Education/Blog/mydapp2/programs/mydapp2) Finished release [optimized] target(s) in 1.07s cargo-build-bpf child: /home/alejandro/.local/share/solana/install/releases/1.8.16/solana-release/bin/sdk/bpf/scripts/strip.sh /home/alejandro/Documentos/Education/Blog/mydapp2/target/bpfel-unknown-unknown/release/mydapp2.so /home/alejandro/Documentos/Education/Blog/mydapp2/target/deploy/mydapp2.so cargo-build-bpf child: /home/alejandro/.local/share/solana/install/releases/1.8.16/solana-release/bin/sdk/bpf/dependencies/bpf-tools/llvm/bin/llvm-readelf --dyn-symbols /home/alejandro/Documentos/Education/Blog/mydapp2/target/deploy/mydapp2.so To deploy this program: $ solana program deploy /home/alejandro/Documentos/Education/Blog/mydapp2/target/deploy/mydapp2.so The program address","date":"2022-03-10","objectID":"/20220310solana/:6:0","tags":["Sistemas distribuidos"],"title":"Programando Dapps en Solana","uri":"/20220310solana/"},{"categories":["Blockchain"],"content":"Construyento la React App En la raíz del proyecto Anchor, crea una nueva react app para sobrescribir el directorio de la app existente: create-react-app app El siguiente paso es instalar la dependencias que vamos a necesitar para Anchor y Solana Web3: cd app yarn add @project-serum/anchor @solana/web3.js También vamos a utilizar Solana Wallet Adapter para controlar las conexiones de la monederos de los usuarios de solana. Para esto hacemos: yarn add @solana/wallet-adapter-react @solana/wallet-adapter-react-ui @solana/wallet-adapter-wallets @solana/wallet-adapter-base A continuación, en el directorio src, crea un nuevo archivo llamado idl.json. Aquí, copie el IDL JSON que fue creado para usted en la carpeta principal del proyecto, ubicado en target/idl/mydapp.json. Sería bueno si pudiéramos copiar este archivo idl automáticamente a nuestra carpeta src de la aplicación cliente, pero hasta ahora no he encontrado una manera de hacer esto de forma nativa. Por supuesto, puedes crear tu propio script que haga esto si lo deseas, o bien necesitas copiar y pegar sobre el IDL después de cada cambio en tu programa principal. Si quieres un script como este, puedes hacerlo en sólo un par de líneas de código: //copyIdl.js const fs = require('fs'); const idl = require('./target/idl/mysolanaapp.json'); fs.writeFileSync('./app/src/idl.json', JSON.stringify(idl)); A continuación, abre app/src/App.js y actualízalo con lo siguiente: import './App.css'; import { useState } from 'react'; import { Connection, PublicKey } from '@solana/web3.js'; import { Program, Provider, web3 } from '@project-serum/anchor'; import idl from './idl.json'; import { PhantomWalletAdapter } from '@solana/wallet-adapter-wallets'; import { useWallet, WalletProvider, ConnectionProvider } from '@solana/wallet-adapter-react'; import { WalletModalProvider, WalletMultiButton } from '@solana/wallet-adapter-react-ui'; require('@solana/wallet-adapter-react-ui/styles.css'); const wallets = [ /* view list of available wallets at https://github.com/solana-labs/wallet-adapter#wallets */ new PhantomWalletAdapter() ] const { SystemProgram, Keypair } = web3; /* create an account */ const baseAccount = Keypair.generate(); const opts = { preflightCommitment: \"processed\" } const programID = new PublicKey(idl.metadata.address); function App() { const [value, setValue] = useState(null); const wallet = useWallet(); async function getProvider() { /* create the provider and return it to the caller */ /* network set to local network for now */ const network = \"http://127.0.0.1:8899\"; const connection = new Connection(network, opts.preflightCommitment); const provider = new Provider( connection, wallet, opts.preflightCommitment, ); return provider; } async function createCounter() { const provider = await getProvider() /* create the program interface combining the idl, program ID, and provider */ const program = new Program(idl, programID, provider); try { /* interact with the program via rpc */ await program.rpc.create({ accounts: { baseAccount: baseAccount.publicKey, user: provider.wallet.publicKey, systemProgram: SystemProgram.programId, }, signers: [baseAccount] }); const account = await program.account.baseAccount.fetch(baseAccount.publicKey); console.log('account: ', account); setValue(account.count.toString()); } catch (err) { console.log(\"Transaction error: \", err); } } async function increment() { const provider = await getProvider(); const program = new Program(idl, programID, provider); await program.rpc.increment({ accounts: { baseAccount: baseAccount.publicKey } }); const account = await program.account.baseAccount.fetch(baseAccount.publicKey); console.log('account: ', account); setValue(account.count.toString()); } if (!wallet.connected) { /* If the user's wallet is not connected, display connect wallet button. */ return ( \u003cdiv style={{ display: 'flex', justifyContent: 'center', marginTop:'100px' }}\u003e \u003cWalletMultiButton /\u003e \u003c/div\u003e ) } else { return ( \u003cdiv className=\"App\"\u003e \u003cdiv\u003e { !value","date":"2022-03-10","objectID":"/20220310solana/:7:0","tags":["Sistemas distribuidos"],"title":"Programando Dapps en Solana","uri":"/20220310solana/"},{"categories":["Blockchain"],"content":"Configurar la red local en la Wallet Antes de poder interactuar con un programa en la red localhost, debemos cambiar nuestro monedero Phantom a la red adecuada. Para ello, abre tu monedero Phantom y haz clic en el botón de configuración. A continuación, desplácese hacia abajo para cambiar la red: Figura 1. Cambiar la redred \" Figura 1. Cambiar la red A continuación, elija Localhost: Figura 2. Seleccionar la redLocalhost \" Figura 2. Seleccionar la red Ahora tenemos que enviar tokens por aire a esta cartera. En la parte superior de la interfaz del monedero, haz clic en tu dirección para copiarla en el portapapeles. Figura 3. Dirección del monederoAddress \" Figura 3. Dirección del monedero A continuación, en una termina ejecutamos el siguiente comando (asegurate que solana-test-validator esté corriendo): solana airdrop 2 «YOUR_ADDRESS» Ahora deberías tener 2 solanas en tu cartera. Ahora podemos ejecutar y probar la aplicación. Cambia al directorio de la aplicación y ejecuta el siguiente comando: yarn start Deberías poder conectar tu cartera, crear un contador e incrementarlo. Notarás que cuando refrescas, pierdes el estado del programa. Esto es porque estamos generando dinámicamente la cuenta base cuando el programa se carga. Si quieres leer e interactuar con los datos del programa a través de varios clientes, tendrías que crear y almacenar el Keypair en algún lugar de tu proyecto. He reunido una idea general de un enfoque ingenuo de cómo podría verse esto. ","date":"2022-03-10","objectID":"/20220310solana/:8:0","tags":["Sistemas distribuidos"],"title":"Programando Dapps en Solana","uri":"/20220310solana/"},{"categories":["Blockchain"],"content":"Despliegue en la Devnet A partir de aquí, el despliegue en una red activa es bastante sencillo. Las principales cosas que tenemos que hacer son: Actualice la CLI de Solana para utilizar devnet: solana config set --url devnet Actualizar el monedero para usar devnet. En el archivo Anchor.toml actualizar el cluster de localnet a devnet. Compilar el programa nuevamente. Asegurate que el ID del programa en Anchor.toml se igual al ID actual del programa. En archivo app/src/App.js, también es necesario actualizar la red, para esto debemos remplazar la red de localhost: http://127.0.0.1:8899 por la red de desarrollo: devnet. /* antes */ \u003cConnectionProvider endpoint=\"http://127.0.0.1:8899\"\u003e /* despues */ import { ..., clusterApiUrl } from '@solana/web3.js'; const network = clusterApiUrl('devnet'); \u003cConnectionProvider endpoint={network}\u003e A partir de aquí, deberías poder desplegar y probar como hemos hecho en los pasos anteriores. Nota El código se encuentra alojado en el github. ","date":"2022-03-10","objectID":"/20220310solana/:9:0","tags":["Sistemas distribuidos"],"title":"Programando Dapps en Solana","uri":"/20220310solana/"},{"categories":["Blockchain"],"content":"El siguiente paso para no parar de aprender Te sugiero continuar aprendiendo sobre NFTs sobre el proyecto de Metaplex. ","date":"2022-03-10","objectID":"/20220310solana/:10:0","tags":["Sistemas distribuidos"],"title":"Programando Dapps en Solana","uri":"/20220310solana/"},{"categories":["Blockchain"],"content":"Patrocinio ₿itcoin: Solana: Ethereum: Paypal: alejandro.driveyali@gmail.com ","date":"2022-03-10","objectID":"/20220310solana/:11:0","tags":["Sistemas distribuidos"],"title":"Programando Dapps en Solana","uri":"/20220310solana/"},{"categories":["Blockchain"],"content":"Imágenes Unplash - 3D illustration of blocks in a blockchain WhatsApp: +917559305753 Email: shubhamdhage000@gmail.com ","date":"2022-03-10","objectID":"/20220310solana/:12:0","tags":["Sistemas distribuidos"],"title":"Programando Dapps en Solana","uri":"/20220310solana/"},{"categories":["Blockchain"],"content":"Referencias Julius Berner. 2021. The Modern Mathematics of deep learning. Yaser Abu-Mostafa Data. 2012 - 2015. Learning From Data. Web3.js ","date":"2022-03-10","objectID":"/20220310solana/:13:0","tags":["Sistemas distribuidos"],"title":"Programando Dapps en Solana","uri":"/20220310solana/"},{"categories":["Agricultura de precisión"],"content":"Una blockchain es una libro de registros de bloques de información que son almacenados secuencialmente y enlazados por métodos criptográficos a través de una red de computadores. Es más que un simple algoritmo, blockchain es una tecnología que facilita la intermediación descentralizada de datos entre los participantes.","date":"2021-07-12","objectID":"/20220312precisionagriculture/","tags":["Sistemas distribuidos"],"title":"Agricultura de precisión","uri":"/20220312precisionagriculture/"},{"categories":["Agricultura de precisión"],"content":"En esta ocasión vamos a aprender cómo monitorizar una planta empleando un bot de telegram y una raspberry pi 3 model b. Este artículo que aquí se desarrolla, busca cubrir la monitorización remota de una plata, asi como la instalación de actuadores que puedan interactuar con la misma. Todo esto controlado desde un bot desarrollado para la plataforma Telegram Messenger. Por lo tanto, el principal objetivo es desarrollar un bot que sea capaz de comunicarse con un servidor, en nuestro caso con una placa Raspberry Pi, y que sea capaz de recibir información de sensores conectados a la placa y enviar órdenes a los actuadores que interactuarán con la planta supervisada. Asimismo, se desarrollará un sistema de gestión de usuarios para permitir al administrador del bot que solo hagan uso del mismo aquellos usuarios legítimos y con los permisos que les hayan concedido. Por lo tanto, será necesario desarrollar esta capa de seguridad. Para el desarrollo de este proyecto, será necesario dominar diferentes tecnologías entre las que, inicialmente, se encuentran: Telegram Messenger: habrá que estudiar cómo se realizan bots en esta plataforma, y averiguar cómo se ponen en funcionamiento y a disposición de los usuarios. Raspberry Pi: será necesario familiarizarse con el entorno Raspberry Pi para poder llegar a usar esta placa para los fines que se ha descrito. ","date":"2021-07-12","objectID":"/20220312precisionagriculture/:0:0","tags":["Sistemas distribuidos"],"title":"Agricultura de precisión","uri":"/20220312precisionagriculture/"},{"categories":["Agricultura de precisión"],"content":"Requisitos del bot Los objetivos generales a cubrir con el bot serán los siguientes: Comprobar la temperatura de la planta. Poder ventilar la planta. Comprobar la humedad ambiental. Poder regar la planta. Controlar el acceso al bot así como los permisos que se asignan a los distintos usuarios. Poder visualizar la planta de manera remota. No obstante, para planificar el correcto desarrollo del bot, hay que pensar en los usuarios que van a utilizarlo. Para ello, se va a hacer un pequeño modelado de usuarios y se verá qué característica tendrán los mismos. Se verá también qué requisitos serán necesarios cumplir para que el bot cubra el alcance del proyecto y permita interactuar con la planta, tal y como se había planificado. Diferenciaremos entre dos tipos de usuarios: los administradores del bot y los usuarios autorizados. Los demás usuarios (usuarios no autorizados) no se tendrán en cuenta, ya que no podrán interactuar con el bot. Los usuarios autorizados podrán interactuar con la planta en función de los permisos que se les hayan asignado. Los permisos, los podrán asignar los usuarios administradores desde el propio bot, e irán desde simples consultas del estado de la planta, hasta tener el control total de la misma. Por lo tanto se ha definido: Usuarios no autorizados: no pueden interactuar con el bot. Usuarios autorizados: pueden actuar con el bot en función de sus permisos. Administradores: son usuarios autorizados con todos los permisos y pueden gestionar a los usuarios. Ahora se pasa a ver qué tipo de requisitos necesita cubrir el bot tanto en la parte del cuidado de la planta como en la gestión de usuarios que se ha comentado. Si queremos conseguir que los usuarios sean capaces de recibir toda la información de los sensores conectados a la Raspberry Pi, y poder actuar con la planta mediante los actuadores, tendresmos que cubrir una serie de requisitos funcionales básicos. Los requisitos funcionales del bot se detallarán a continuación: **Requisitos relacionados con los sensores: Ver el estado de l planta Visualizar la temperatura Visualizar la humedad Solicitar una fotografía de la planta Requisitos relacionados con los actuadores: Encender/apagar la luz Encender/apagar la ventilación Regar la planta Y en cuanto a la gestión de usuarios, será necesario gestionar estas funcionalidades: Solicitar permisos de uso Admitir usuarios que han solicitado permiso Restringir usuarios Cambiar permisos a usuarios Ahora, se va a estudiar los perfiles de usuario que se pueden crear, y qué requisitos asignar a cada uno de ellos. Usuario sin permisos, podrá: Solicitar permiso para utilizar el bot Y se definen tres tipos de usuarios con permisos: Usuario «supervisor», para supervisar la planta, podrá: Solicitar más permisos Ver estado de la planta Visualizar temperatura Visualizar humedad ambiental Usuario «jardinero», además de los anteriores permisos, podrá: Solicitar una fotografía de la planta Encender/apagar luz Encender/apagar ventilación Regar la planta Usuario «administrador», tendrá todos los permisos anteriores, así como los relativos a la gestión de usuarios. Los propios de gestión de usuarios permitirán: Conceder permisos de uso Denegar permisos de uso Ascender a un usuario a un perfil superior Degradar a un usuario a un perfil inferior Con todo esto, ya se tiene una imagen más clara de todas las acciones que permitir realizar el sistema. En base a ellas, se desarrollarán tanto las soluciones hardware como software. ","date":"2021-07-12","objectID":"/20220312precisionagriculture/:1:0","tags":["Sistemas distribuidos"],"title":"Agricultura de precisión","uri":"/20220312precisionagriculture/"},{"categories":["Agricultura de precisión"],"content":"Tecnologías Tal y como se ha definido previamente, se emplearán sensores y actuadores conec- tados directamente a la placa Raspberry Pi que, a su vez, alojará tanto el bot que se desarrollará en lenguaje Python como la base de datos necesaria para su funcionamiento. Todas estas tecnologías y las subyacentes se explican en este apartado. Se comenzará hablando del hardware, con mayor incidencia en Raspberry Pi, y des- pués se pasará al software, con mención especial para Telegram y la base de datos. ","date":"2021-07-12","objectID":"/20220312precisionagriculture/:2:0","tags":["Sistemas distribuidos"],"title":"Agricultura de precisión","uri":"/20220312precisionagriculture/"},{"categories":["Agricultura de precisión"],"content":"Hardware Raspberry Pi Raspberry Pi es un ordenador de placa reducida de bajo coste, desarrollado en Reino Unido por la fundación Raspberry Pi, con el objetivo principal de incitar tanto a niños como a adultos a que aprendan sobre ordenadores y todo lo relacionado con los mismos. La idea de desarrollar algo así surgió en 2006 cuando Eben Upton, Rob Mullins, Jack Lang y Alan Mycroft, del laboratorio de informática de la Universidad de Cambridge, constataron cómo habían cambiado los conocimientos de los niños sobre la informática. En la década de los 90, surgió mucha afición por la programación entre la juventud, pero a partir del año 2000 la tendencia fue disminuyendo y esa inquietud se dirigió, principal- mente, a la programación web, de mucho más alto nivel. La fundación Raspberry Pi surgió con un objetivo en mente: Desarrollar el uso y entendimiento de los ordenadores en los niños. Su idea es conseguir ordenadores muy baratos que permitan a los niños usarlos sin miedo, abriendo su mentalidad, y educándolos en la ética del «ábrelo y mira cómo funciona». En este proyecto se trabajará con una placa Raspberry Pi 3 modelo B. Las característi- cas de este modelo son las siguientes: *** Buscar las características Sensores y actuadores En este apartado, veremos las características de los sensores que se emplearán para monitorizar la planta. En primer lugar, se nombran todas las funciones que cubren los sensores: Medida de temperatura Medida de humedad Toma de fotografías Estas funciones se traducirán en un sensor de temperatura y humedad y una cámara web. Para el sensor de temperatura y humedad ambiental, se va a contar con el sensor DHT11. Se trata de un sensor digital de alta fiabilidad y estabilidad, por su señal digital calibrada. Se ha adquirido un sensor con placa PCB, donde va insertado para facilitar su uso. Transmisión de datos del sensor DHT11 Aunque se ha dicho que el sensor es digital, en realidad esto no es del todo correcto, ya que realmente el sensor es analógico, pero internamente se realiza la conversión a se- ñal digital, y la devuelve en una trama como la que se muestra a continuación. Como se puede ver, el primer grupo de 8 bits es la parte entera de la humedad, y el segundo la parte decimal. Lo mismo para la temperatura, donde la parte entera sería el tercer grupo, y la parte decimal el cuarto. Por último se encuentran los bits de paridad para confirmar que no hay datos corruptos. Actualmente existen librerías que recogen estas tramas y devuelven los valores en de- cimal. Una de estas librerías es Adafruit. Para poder utilizar la librería Adafruit, se deberá instalar desde su repositorio en lí- nea y, una vez hecho, ya se podrá solicitar los datos al sensor, y así recibirlos en consola *** Agregar foto Cámara web Para la toma de fotografías se va a emplear una cámara web. Se consulta en Internet el listado de cámaras compatibles con Raspberry Pi para comprobar si se tiene alguna de las listadas o, en su defecto, buscar una compatible para comprar Actuadores Para actuar con la planta, se contará con una serie de componentes para: Ventilación del invernadero Riego de la planta Iluminación del invernadero Ventilador Para llevar a cabo la ventilación del invernadero, se va a contar con un pequeño ven- tilador diseñado para refrigerar ordenadores portátiles que, debido a su tamaño, es suficiente para el cometido, y que tan solo requiere un potencial de 5 voltios para su alimen- tación. Continuará … ","date":"2021-07-12","objectID":"/20220312precisionagriculture/:2:1","tags":["Sistemas distribuidos"],"title":"Agricultura de precisión","uri":"/20220312precisionagriculture/"},{"categories":["Agricultura de precisión"],"content":"Imágenes Unplash - Sunset over Limuru tea farm. ","date":"2021-07-12","objectID":"/20220312precisionagriculture/:3:0","tags":["Sistemas distribuidos"],"title":"Agricultura de precisión","uri":"/20220312precisionagriculture/"},{"categories":["Agricultura de precisión"],"content":"Referencias Julius Berner. 2021. The Modern Mathematics of deep learning. Yaser Abu-Mostafa Data. 2012 - 2015. Learning From Data. ","date":"2021-07-12","objectID":"/20220312precisionagriculture/:4:0","tags":["Sistemas distribuidos"],"title":"Agricultura de precisión","uri":"/20220312precisionagriculture/"},{"categories":["Blockchain"],"content":"Una blockchain es una libro de registros de bloques de información que son almacenados secuencialmente y enlazados por métodos criptográficos a través de una red de computadores. Es más que un simple algoritmo, blockchain es una tecnología que facilita la intermediación descentralizada de datos entre los participantes.","date":"2021-07-12","objectID":"/20220209blockchainfoundations/","tags":["Sistemas distribuidos"],"title":"Fundamentos de la tecnología Blockchain","uri":"/20220209blockchainfoundations/"},{"categories":["Blockchain"],"content":"Comming soon … ","date":"2021-07-12","objectID":"/20220209blockchainfoundations/:0:0","tags":["Sistemas distribuidos"],"title":"Fundamentos de la tecnología Blockchain","uri":"/20220209blockchainfoundations/"},{"categories":["Inteligencia Artificial"],"content":"¿Cómo aprendemos los humanos? En principio la mayoría del conocimiento humano proviene de nuestra experiencia con los objetos, es decir, aprendemos de los datos que obtenemos acerca de ellos y no a partir de algún tipo de definición matemática.","date":"2021-07-12","objectID":"/20210712machinelearning/","tags":["Machine Learning","Tareas de aprendizaje","Regresión","Clasificación"],"title":"Aprendiendo de los datos","uri":"/20210712machinelearning/"},{"categories":["Inteligencia Artificial"],"content":"¿Cómo aprendemos los humanos? En principio la mayoría del conocimiento humano proviene de nuestra experiencia con los objetos, es decir, aprendemos de los datos que obtenemos acerca de ellos y no a partir de algún tipo de definición matemática. Esta habilidad de aprender de los datos, nos ha resultado bastante útil, dado que existe una amplia variedad de problemas que no se pueden resolver de forma analítica. En estas situaciones los datos nos permiten encontrar soluciones empíricas, que no necesariamente explican el porqué de las cosas, pero si ofrecen resultados útiles para la práctica. Por esta razón, la capacidad de aprender a partir de los datos es una técnica de mucha importancia para todas las profesiones y disciplinas. En esta ocasión vamos a tratar brevemente los principales elementos que constituyen el problema del aprendizaje a partir de los datos, para finalmente entender un poco cómo las máquinas también pueden aprender. ","date":"2021-07-12","objectID":"/20210712machinelearning/:0:0","tags":["Machine Learning","Tareas de aprendizaje","Regresión","Clasificación"],"title":"Aprendiendo de los datos","uri":"/20210712machinelearning/"},{"categories":["Inteligencia Artificial"],"content":"El problema del aprendizaje El poder aprender a partir de los datos es un proceso que puede ser automatizado, es decir, se pueden elaborar algoritmos que realizan esta tarea. En este punto es importante entender que los algoritmos que aprenden de los datos solo tratan de encontrar la mejor solución para predecir resultados, y no necesariamente encuentran el porqué. Aquí los datos guían a los algoritmos para construir la fórmula que ofrece las mejores aplicaciones en el sentido práctico. En un sentido más matemático, el problema del aprendizaje se puede formular a partir de tres espacios medibles $\\mathcal{X}$, $\\mathcal{Y}$ y $\\mathcal{Z}$, en donde el conjunto $\\mathcal{Z}$ es un subconjunto de $\\mathcal{X} \\times \\mathcal{Y}$ que representa a una relación entre los datos de $\\mathcal{X}$ e $\\mathcal{Y}$. En principio, la tarea de aprendizaje consiste en tratar de describir la relación $\\mathcal{Z}$ a partir de una muestra de datos $S=(s_{i})_{i\\in [m]} \\in \\mathcal{Z}^{m}$ y alguna función de perdida $\\mathcal{L}: \\mathcal{M}( \\mathcal{X}, \\mathcal{Y} )\\times \\mathcal{Z} \\to \\mathbb{R}$ definida sobre el producto cartesiano entre el conjunto $\\mathcal{M}( \\mathcal{X}, \\mathcal{Y} )$ de todas las funciones medibles de $\\mathcal{X}$ a $\\mathcal{Y}$ y el conjunto $\\mathcal{Z}$, y con imagen en los número reales. La función $\\mathcal{L}$ se emplea principalmente para medir cúal es el performance del aprendizaje en el algoritmo. Resolver esta tarea implica hacer la elección de un conjunto de hipótesis $\\mathcal{H} \\subset \\mathcal{M}( \\mathcal{X}, \\mathcal{Y} )$ y la construcción de un algoritmo de aprendizaje, es decir, encontrar un mapeo: \\begin{equation} \\mathcal{A}: \\bigcup_{ m\\in \\mathbb{N} } \\mathcal{Z}^{m} \\to \\mathcal{H} \\end{equation} que a partir de una muestra de datos $S = (s_i)_{i\\in[m]}$ de cierto tamaño $m$ logre encontrar un modelo $h_S = \\mathcal{A}(S)\\in \\mathcal{H}$ con «buen comportamiento» en $S$ y «capacidad de generalizar» para los datos desconocidos en $\\mathcal{Z} \\setminus \\{s_i\\}_{i\\in[m]}$. Aquí, el buen comportamiento se mide via la función de perdida $\\mathcal{L}$ y corresponde a la perdida $\\mathcal{L}(h_S, z)$, mientras la capacidad de generalizar quiere decir que el comportamiento de $h_S$ en $z\\in \\mathcal{Z} \\setminus \\{s_i\\}_{i\\in[m]}$ es similar a $z\\in \\mathcal{S}$. Creo que en este punto, estamos de acuerdo con que las nociones de «buen comportamiento» y «la capacidad de generalizar» son bastante vagas, sin embargo, veamos como mejorar estas ideas, para lograr esto vamos a centrar la atención en los conceptos de riesgo ideal y de riesgo empírico cómo veremos a continuación. El riesgo ideal de una hipótesis $h\\in \\mathcal{H}$ con respecto a la distribucción de probabilidad $\\mathcal{D}$ sobre $\\mathcal{Z}$, se define como: \\begin{equation}\\tag{1} L_{D}(h) = \\mathbb{E}_{z\\sim \\mathcal{D}}[\\mathcal{L}(h, z)]. \\end{equation} Observe que para esta definición, la esperanza de la función de perdida de $h$ es sobre los datos de $z$ muestreados aleatoriamente de acuerdo con la distribucción $\\mathcal{D}$. Hay que señalar que en la práctica la distribución $\\mathcal{D}$ es esencialmente desconocida. Por otro lado, el riesgo empírico es la perdida esperada sobre una muestra de datos $S = (s_i)_{i \\in[m]}$, es decir: \\begin{equation}\\tag{2} L_{S}(h) = \\frac{1}{m}\\sum_{i=1}^{m}\\mathcal{L}(h, s_i). \\end{equation} Ahora bien, si existiera el modelo $h^*\\in \\mathcal{H}$ tal que el riesgo ideal es cero, $L_{D}(h^*)=0$, entonces el riesgo empírico también sería cero, $L_{S}(h^*)=0$, pues el modelo no presentaría ningún error en su tarea de predicción, aunque esto es lo esperado, por lo general, no es posible encontrar un modelo con las características de $h^*$. En la práctica para encontrar el mejor modelo, los esfuerzos se centran en una muestra de datos $S = (s_i)_{i \\in[m]}$ y un conjunto de hipótesis $\\mathcal{H}$, de tal manera que el objetivo ahora es encontrar un modelo $h_s\\in \\mathcal{H}$ que satisfa","date":"2021-07-12","objectID":"/20210712machinelearning/:1:0","tags":["Machine Learning","Tareas de aprendizaje","Regresión","Clasificación"],"title":"Aprendiendo de los datos","uri":"/20210712machinelearning/"},{"categories":["Inteligencia Artificial"],"content":"Tareas de predicción y clasificación Veamos algunos ejemplos de problema de aprendizaje basados en datos: Clasificación Multiclase. Consideremos la tarea de clasificar documentos. Nuestro deseo es diseñar un programa con la capacidad para clasificar una colección de documentos, de acuerdo a diferentes tópicos (e.g., noticias, deportes, biología, medicina). Un algoritmo de aprendizaje para esta tarea debería tener acceso a una colección de documentos correctamente clasificados, $S$, y con base a estos ejemplos, debería entregar una programa (modelo) que puede tomar un nuevo documento y clasificarlo. Aquí el dominio, $\\mathcal{X}$, es el conjunto de todos los posibles documentos. Es importante señalar, que los documentos debería ser representados por un conjunto de características, que podría incluir el número de palabras diferentes en cada documento, el tamaño de cada documento, el autor, el origen, etc. Las etiquetas, $\\mathcal{Y}$, es el conjunto de todos los posibles tópicos (en este caso, debería ser algún conjunto finito). Una vez hemos identificado el dominio y las etiquetas, el otro componente que hace falta es determinar una función de perdida adecuada para medir el performance de nuestro algoritmo. Para el caso de la clasificación multiclase se puede considerar la variable aleatoria $z$ en $\\mathcal{X}\\times \\mathcal{Y}$ con la siguiente función de perdida: \\begin{equation} \\mathcal{L}(h, (x, y)) = \\begin{cases} 0 \\mbox{ si } h(x) = y, \\newline \\newline 1 \\mbox{ si } h(x)\\neq y. \\end{cases} \\end{equation} Esta función se usa en general para problemas de clasificación binaria o multiclase. Regresión. En esta tarea, el objetivo es encontrar algún patrón simple en los datos –una relación funcional entre los componentes de los datos $\\mathcal{X}$ e $\\mathcal{Y}$–. Por ejemplo, encontrar la mejor función que predice el peso de nacimiento de un bebe en relación con las medidas obtenidas por ultrasonido del diámetro de su cabeza, el diámetro abdominal y la longitud de su fémur. Aquí el dominio es algún subconjunto de $\\mathbb{R}^{3}$ (las tres medidas obtenidas por el ultrasonido) y las etiquetas es el conjunto de los números reales (el peso en gramos). En este caso el conjunto de entrenamiento es igual que antes, un subconjunto $S\\subseteq \\mathcal{X}\\times \\mathcal{Y}$. Sin embargo, la medida de éxito es diferente. En este ejemplo, se podría evaluar la calidad de la hipótesis $h:\\mathcal{X}\\to \\mathcal{Y}$ por el valor esperado del cuadrado de la diferencia entre las etiquetas correctas y su predicción, es decir: \\begin{equation} \\mathcal{L}(h, (x,y)) = (h(x)-y)^2. \\end{equation} ","date":"2021-07-12","objectID":"/20210712machinelearning/:2:0","tags":["Machine Learning","Tareas de aprendizaje","Regresión","Clasificación"],"title":"Aprendiendo de los datos","uri":"/20210712machinelearning/"},{"categories":["Inteligencia Artificial"],"content":"¿Cómo aprenden las maquinas? Como vimos anteriormente, el problema del aprendizaje involucra la elección de un conjunto de hipótesis $\\mathcal{H}$ y la búsqueda de la hipótesis $h_{s}$ tal que: \\begin{equation} h_s \\in \\operatorname*{argmin}_{h\\in \\mathcal{H}} L_{S}(h). \\end{equation} En otras palabras, el problema del aprendizaje se reduce a un problema de optimización del riesgo empírico $\\mathcal{L}_{S}(h)$. Para resolver este tipo de problemas existe una amplia variedad de algoritmos de optimización de funciones, en particular para estas tareas el algoritmo por excelencia es el algoritmo del descenso del gradiente, este consiste en general en realizar la siguiente iteración \\begin{equation} h \\leftarrow h - \\lambda \\nabla L_{D}(h) \\end{equation} para encontrar una hipótesis $h_s$. Este es un proceso que puede ser automatizable en casi cualquier computadora. Por lo tanto, en principio cualquier máquina con la capacidad de ejecutar este tipo de iteraciones, estaría en la capacidad de aprender a clasificar y predecir a partir de los datos. Sin embargo, hay que indicarle a la computadora cómo debe aprender, para esto se debe programar una serie de órdenes en las que se le indica como optimizar las diferentes funciones de perdida, según la tarea de aprendizaje que le deseamos enseñarle, una vez los algoritmos se haya ejecutado, la computadora debería estar en la capacidad de clasificar y predecir, obviamente esto no es una tarea sencilla, pero no es imposible. Dejaré por el momento esta publicación hasta aquí, para no hacerla más extensa, espero que la hayan disfrutado. Nos vemos pronto. ","date":"2021-07-12","objectID":"/20210712machinelearning/:3:0","tags":["Machine Learning","Tareas de aprendizaje","Regresión","Clasificación"],"title":"Aprendiendo de los datos","uri":"/20210712machinelearning/"},{"categories":["Inteligencia Artificial"],"content":"Referencias Julius Berner. 2021. The Modern Mathematics of deep learning. Yaser Abu-Mostafa Data. 2012 - 2015. Learning From Data. ","date":"2021-07-12","objectID":"/20210712machinelearning/:4:0","tags":["Machine Learning","Tareas de aprendizaje","Regresión","Clasificación"],"title":"Aprendiendo de los datos","uri":"/20210712machinelearning/"},{"categories":["Inteligencia Artificial"],"content":"¿Cómo aprendemos los humanos? En principio la mayoría del conocimiento humano proviene de nuestra experiencia con los objetos, es decir, aprendemos de los datos que obtenemos acerca de ellos y no a partir de algún tipo de definición matemática.","date":"2022-02-10","objectID":"/20200212svd/","tags":["Machine Learning","Tareas de aprendizaje","Regresión","Clasificación"],"title":"Descomposición matricial por valores singulares (SVD)","uri":"/20200212svd/"},{"categories":["Inteligencia Artificial"],"content":"En esta ocasión vamos a introducir la descomposición por valores singulares (SVD por sus siglas en inglés) y cómo aplicar la SVD mediante ejemplos prácticos desarrollados en Python, Rust y C++. Es importante entender la SVD porque es el fundamento otras técnicas de aprendizaje mecánico, como lo es los métodos de clasificación, la descomposición dinámica (DMD) y la descomposición ortogonal propia (POD). La alta dimensionalidad es un reto común en el procesamiento de datos que proviene de sistemas complejos. Por ejemplo con datos que provienes de fuentes de audio, video o imagenes. Los datos también puede ser generados por sistemas físicos, como lo es el registros de interacciones neuronales de un cerebro, o la registros de velocidad de una simulación del movimiento de un fluido o experimento.Es natural que en la mayoría de los sistemas, los datos exhiban patrones dominantes, que pueden ser caracterizados por atractores o variedades de dimensionalidad baja. La SVD provee una forma sistemática para determinar una aproximación de baja dimensionalidad a un conjunto de datos de alta dimensionalidad en términos de los patrones dominantes. Esta técnica «direcciona los datos» en descubrir esos patrones propiamente de los datos, si recurrir al conocimiento del experto de los datos o la intuición. La SVD es numéricamente estable y provee una representación herarquica de los datos en términos de un nuevo sistema de coordenadas definido por las correlaciones dominantes en los datos. Además, la SVD existe para cualquier matriz, lo que la diferencias de la descomposición por valores propios. La SVD tiene aplicaciones muy importantes que van más allá de la reducción de dimensionalidad de datos de alta dimensionalidad. Es usada para calcular las psudo-inversa de matrices no cuadradas, proporcionando soluciones a sisteamas de ecuaciones matriciales infradeterminadas o sobredeterminadas, $\\pmb{A}x=b$. La SVD también se emplea para la reducción de ruido en conjunto de datos. La SVD también es igual de importante para caracterizar la geometria de entrada y salida de una transformación lineal entre espacios vectoriales. (Agregar referencias). ","date":"2022-02-10","objectID":"/20200212svd/:0:0","tags":["Machine Learning","Tareas de aprendizaje","Regresión","Clasificación"],"title":"Descomposición matricial por valores singulares (SVD)","uri":"/20200212svd/"},{"categories":["Inteligencia Artificial"],"content":"Definición de la SVD En general, el objetivo es analizar un conjunto de datos con la estructura $X\\in \\mathcal{C}^{n\\times m}$: \\begin{equation} X=\\begin{pmatrix} | \u0026 | \u0026 \u0026 | \\\\ x_1 \u0026 x_2 \u0026 \\cdots \u0026 x_m \\\\ | \u0026 | \u0026 \u0026 | \\\\ \\end{pmatrix}. \\end{equation} La columnas $x_k\\in \\mathcal{C}^{n}$ puede ser medidas de una simulación o resultados de un experimento. Por ejemplo, las columnas puede representar imagenes que han sido reorganizadas en vectores columnas en donde cada entrada es un pixel en la imagen. El indice $k$ es una etiqueta que indica el registro $k$-ésimo de las medidas. En muchas ocasiones, $X$ consiste de una serie de datos, de tal forma que $x_k =x(k\\delta t)$. Con frecuencia de la dimensión $n$ es muy grande, en un orden de un millón o billones de grados de libertad. La columna amenudo se denomina registros, y $m$ es el número de registros en $X$. Para muchos sistemas $n\\gg m$, resultando en una matrix tall-skinny, que es opuesta a una matriz short-fat cuando $n\\ll m$. La SVD es una descomposición matricial única que existe para todas las matrices $X\\in \\mathcal{C}^{n\\times m}$: \\begin{equation} X= U\\Sigma V^{*} \\end{equation} donde $U\\in \\mathcal{C}^{n\\times n}$ y $V\\in \\mathcal{C}^{m\\times m}$ son matrices unitarias con columnas ortonormales, y $\\Sigma \\in \\mathcal{R}^{n\\times m}$ es una matriz con entradas reales, no negativas en la diagonal principal y cero en fuera de ella. Aquí $^*$ denota la transposición de matrices complejas. Cuando $n\\geq m$, la matriz $\\Sigma$ tiene al menos $m$ elementos no nulos sobre la diagonal principal, así que la matriz $\\Sigma$ se puede escribir como $\\Sigma = \\begin{bmatrix} \\hat{\\Sigma} \\\\ 0 \\end{bmatrix}$. Por lo tanto, una representación exacta de $X$ usando la descomposición económica de SVD: \\begin{equation} X=U\\Sigma V^{*} = \\begin{bmatrix} \\hat{U} \u0026 \\hat{U}^{\\perp}\\end{bmatrix}\\begin{bmatrix}\\hat{\\Sigma} \\\\ 0 \\end{bmatrix} V^{*} = \\hat{U}\\hat{\\Sigma} V^{*}. \\end{equation} La decomposición completa SVD y la decomposición económica SVD se ilustran en la figura (xxx). Las columnas de $\\hat{U}^{\\perp}$ generan el espacio vectorial que es complementario y ortogonal al espacio generado por $\\hat{U}$. Las columnas de $U$ se denominan vectores singulares a izquierda de $X$ y las columnas de $V$ son los vectores singulares a derecha. Los elementos de la diagonal de $\\hat{Sigma}\\in \\mathcal{C}^{m\\times m}$ se denominan valores propios y son ordenados de de mayor a menor. El rango de $X$ es igual al número de valores singulares no nulos. ","date":"2022-02-10","objectID":"/20200212svd/:1:0","tags":["Machine Learning","Tareas de aprendizaje","Regresión","Clasificación"],"title":"Descomposición matricial por valores singulares (SVD)","uri":"/20200212svd/"},{"categories":["Inteligencia Artificial"],"content":"Calculando la descomposición SVD La descomposición SVD es la piedra angular de la ciencia computacional y la ingeniería. Su implementación númerica es importante y matemáticamente esclarecedora. Dicho esto, la mayoría de las implementaciones númericas están desarrolladas e implementadas con una interfaz simple en la mayoría de los lenguajes de programación modernos, lo que nos permite abstraer los detalles computacionales que hay detrás de la descomposición SVD. Para la mayoría de los propositos, nosotros vamos a asumir que SVD proviene ya de un esfuerzo colectivo mayor y que por lo tanto ya viene garantizada la existencia de eficiencia y estabilidad de los algoritmos que vamos a emplear. A continuación, vamos a ilustrar como usar la descomposición SVD en varios lenguajes de programación. ","date":"2022-02-10","objectID":"/20200212svd/:2:0","tags":["Machine Learning","Tareas de aprendizaje","Regresión","Clasificación"],"title":"Descomposición matricial por valores singulares (SVD)","uri":"/20200212svd/"},{"categories":["Inteligencia Artificial"],"content":"SVD con Python import numpy as np # Create radom data matrix X = np.random.rand(5, 3) # full SVD U, S, V = np.linalg.svd(X, full_matrices=True) # economy SVD U_hat, S_hat, V_hat = np.linalg.svd(X, full_matrices=False) ","date":"2022-02-10","objectID":"/20200212svd/:2:1","tags":["Machine Learning","Tareas de aprendizaje","Regresión","Clasificación"],"title":"Descomposición matricial por valores singulares (SVD)","uri":"/20200212svd/"},{"categories":["Inteligencia Artificial"],"content":"Otros lenguajes La descomposición SVD también está disponible en otros lenguajes, como Fortran, C++, Rust, R, Julia. En efecto, la mayoría de las implementaciones de SVD se basan en LAPACK en Fortran. La rutina de SVD se designa como DGESVD en LAPACK, y esto está envuelto en las librerías Armadillo y Eigen de C++. ","date":"2022-02-10","objectID":"/20200212svd/:2:2","tags":["Machine Learning","Tareas de aprendizaje","Regresión","Clasificación"],"title":"Descomposición matricial por valores singulares (SVD)","uri":"/20200212svd/"},{"categories":["Inteligencia Artificial"],"content":"Referencias Julius Berner. 2021. The Modern Mathematics of deep learning. Yaser Abu-Mostafa Data. 2012 - 2015. Learning From Data. ","date":"2022-02-10","objectID":"/20200212svd/:3:0","tags":["Machine Learning","Tareas de aprendizaje","Regresión","Clasificación"],"title":"Descomposición matricial por valores singulares (SVD)","uri":"/20200212svd/"}]