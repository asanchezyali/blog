[{"categories":["Blockchain"],"content":"Una blockchain es una libro de registros de bloques de información que son almacenados secuencialmente y enlazados por métodos criptográficos a través de una red de computadores. Es más que un simple algoritmo, blockchain es una tecnología que facilita la intermediación descentralizada de datos entre los participantes","date":"2022-03-10","objectID":"/20220310solana/","tags":["Sistemas distribuidos"],"title":"Programando Dapps sobre Solana","uri":"/20220310solana/"},{"categories":["Blockchain"],"content":"El objetivo de este artículo es proveer una guía completamente en español de cómo construir una aplicación descentralizada (dapp) en la cadena de bloques de Solana. En principio los voy a introducir en el ecosistema de herramientas más comunes para desarrollar en este Blockchain. Espero que el contenido que voy a presentar sea de su agrado y logren desarrollar sus propias aplicaciones. ","date":"2022-03-10","objectID":"/20220310solana/:0:0","tags":["Sistemas distribuidos"],"title":"Programando Dapps sobre Solana","uri":"/20220310solana/"},{"categories":["Blockchain"],"content":"Comunidades de programadores de dapps con Solana Antes de comenzar es importante señalar que el ecosistema de Solana es relativamente joven y que muchas de la herramientas que se emplean para el desarrollo se está constantemente actualizando, por lo que muchas veces la documentación oficial muchas veces no está actualizada, asi que mi recomendación es unirse a las comunidades del proyecto y en caso de tener dificultades para desarrollar sus productos, allí puedes encontrar respuesta a tus preguntas en conversaciones, además de participar dde las discusiones del comunidad. A continuación les dejo algunos de los canales de discord que me han sido de mucha utilidad: Anchor ","date":"2022-03-10","objectID":"/20220310solana/:1:0","tags":["Sistemas distribuidos"],"title":"Programando Dapps sobre Solana","uri":"/20220310solana/"},{"categories":["Blockchain"],"content":"Introducción a las herramientas del ecosistema de Solana La herramientas que vamos a incluir en este artículo son: Solana Tool Suite - Esta es la CLI de Solana. La documentación es muy completa y allí encontrarán todos los detalles para aprender a utilizarla. A la fecha de escribir este artículo, yo estaba utilizando la version 1.8.16. Anchor Framework - Seguramente si has desarrollado dapps sobre Ethereum, habrás utilizado Hardhat. Bueno, Anchor es un framework parecido a Hardhat que se utiliza para desarrollar dapps sobre Solana. La versión que utilzaré para este artículo sera la 0.21.0. solana/web3.js - Es una version de web3.js para solona, sin embargo la documentación no es muy buena, así que si tienes dificultades con ellas busques apoyo en las comunidades de discord. React.js - Framework para el desarrollo de Front-end. Bastante popular y con muy buena documentación. En artículo futuros trataré de explicar en que consiste la tecnología Blockchain y cuáles son las características principales de Solana. Por ahora solo nos centraremos en construir un ejemplo que sirva de ilustración para entender cómo desarrollar una dapp sobre Solana. Si quieres aprender más sobre Solana y cómo funciona, aquí hay algunos artículos muy buenos: Documentación oficial de Solana. Solana Summer. *** Hacer una breve descripción del proyecto que vamos a construir. ","date":"2022-03-10","objectID":"/20220310solana/:2:0","tags":["Sistemas distribuidos"],"title":"Programando Dapps sobre Solana","uri":"/20220310solana/"},{"categories":["Blockchain"],"content":"Prerequisitos A continuación, enumeraré las dependencias y enlazaré con la documentación para instalarlas, ya que cada proyecto explica y tiene documentado estas cosas mejor de lo que yo podría, además de mantenerlas actualizadas. Node.js - Yo recomiendo utilizar la version 16.04. Para instalarla pueden usar nvm. Solana Tool Suite. La instrucciones de instalación se encuentran en la documentación oficial de Solana. Yo estoy usando actualmente el sistema operativo Manjaro. Anchor (incluyendo la instalación de Mocha) - La instrucciones de instalación se encuentran aqui. Solana browser wallet - Te recomiendo usar Phantom. En el desarrollo de nuestro proyecto vamos a probarlo utilizando esta wallet. ","date":"2022-03-10","objectID":"/20220310solana/:3:0","tags":["Sistemas distribuidos"],"title":"Programando Dapps sobre Solana","uri":"/20220310solana/"},{"categories":["Blockchain"],"content":"Solana CLI Las principales cosas que haremos con el CLI de Solana serán configurar nuestra red (entre localhost y una red de prueba para desarrolladores) así como lanzar tokens a nuestras carteras, prácticamente todo lo demás lo haremos con el CLI de Anchor. Por ejemplo, podemos comprobar la configuración actual de la red (y otras) con este comando: solana config get #output Config File: /home/user/.config/solana/cli/config.yml RPC URL: https://api.devnet.solana.com WebSocket URL: wss://api.devnet.solana.com/ (computed) Keypair Path: /home/user/.config/solana/devnet.json Commitment: confirmed Nota Si no tiene una ruta de acceso a Keypair, configure una siguiendo las instrucciones aquí. Para utilizar las redes localhost, devnet o mainnet, podemos hacer lo siguiente: # set to localhost solana config set --url localhost # set config devnet solana config set --url devnet # set config mainnet solana config set --url mainnet # Output Config File: /home/user/.config/solana/cli/config.yml RPC URL: https://api.devnet.solana.com WebSocket URL: wss://api.devnet.solana.com/ (computed) Keypair Path: /home/user/.config/solana/devnet.json Commitment: confirmed Esto es importante ya que es importante estar al tanto de qué red estás usando mientras construyes, pruebas y despliegas tus programas. Asegurate de que tu cartera está usando la misma red que tu entorno local. Vamos a desarrollar nuestra aplicación en la red de devnet, para esto ejecutamos: # set config devnet solana config set --url devnet También podemos usar el CLI para ver la dirección de nuestro monedero local actual: solana address # Output is something like this: 4aDSG82CdgMwt81z7AwnLnDRZyp6MjvZMUVpT82HZRU9 Para obtener la información completa de la cuenta: solana account «YOUR ADDRESS» # Output is something like this: Public Key: 4aDSG82CdgMwt81z7AwnLnDRZyp6MjvZMUVpT82HZRU9 Balance: 4.956381584 SOL Owner: 11111111111111111111111111111111 Executable: false Rent Epoch: 277 A continuación vamos a conseguir algo de Solana, para hacer esto, asegurate de que te encuentras en la devnet, ya que nuestra dapp va funcionar en esta red. Para conseguir solanas hacemos: solana airdrop 2 4aDSG82CdgMwt81z7AwnLnDRZyp6MjvZMUVpT82HZRU9 --url devnet # Output is something like this: Requesting airdrop of 2 SOL Signature: 3KsFBCULmso5Lc7CAQdqF8rzsBXb3xaVrG3cup19n3P2paw3ryvovWQ9MsMB8GMiQkXJWyHXGrni63BsNrxVfHP2 2 SOL Si deseas trabajar con la red en localhost, primero deberás inicial el nodo local de Solana para realizar la pruebas: solana-test-validator #Output is something like this: Ledger location: test-ledger Log: test-ledger/validator.log Identity: D2tKzcNv1iLwWpQpEhwSXvuPH5vQUXy8jwCYvGEUzgZv Genesis Hash: 3qied4BanGash7eNA46H3UwnP3VLa96gYnMtDgEdQK3T Version: 1.8.16 Shred Version: 38112 Gossip Address: 127.0.0.1:1024 TPU Address: 127.0.0.1:1027 JSON RPC URL: http://127.0.0.1:8899 ..... Y luego solana airdrop 2 4aDSG82CdgMwt81z7AwnLnDRZyp6MjvZMUVpT82HZRU9 --url localhost # Output is something like this: Requesting airdrop of 1 SOL Signature: 3KsFBCULmso5Lc7CAQdqF8rzsBXb3xaVrG3cup19n3P2paw3ryvovWQ9MsMB8GMiQkXJWyHXGrni63BsNrxVfHP2 1 SOL Para verificar el balance de nuestro monedero hacemos: solana balance «YOUR ADDRESS» Ahora que ya tienes solanas en tu monedero, podemos continuar con la siguiente fase de nuestro proyecto. ","date":"2022-03-10","objectID":"/20220310solana/:4:0","tags":["Sistemas distribuidos"],"title":"Programando Dapps sobre Solana","uri":"/20220310solana/"},{"categories":["Blockchain"],"content":"Empezando a construir una dapp con Anchor Para iniciar, creamos un nuevo proyecto de Anchor y cambiamos al nuevo directorio: anchor init mydapp --javascript cd mydapp # Output is something like this: yarn install v1.22.17 warning package.json: No license field info No lockfile found. warning No license field [1/4] Resolving packages... warning @project-serum/anchor \u003e @solana/web3.js \u003e rpc-websockets \u003e circular-json@0.5.9: CircularJSON is in maintenance only, flatted is its successor. [2/4] Fetching packages... [3/4] Linking dependencies... warning \" \u003e ts-mocha@8.0.0\" has incorrect peer dependency \"mocha@^3.X.X || ^4.X.X || ^5.X.X || ^6.X.X || ^7.X.X || ^8.X.X\". [4/4] Building fresh packages... success Saved lockfile. Done in 11.66s. mydapp initialized Si deseamos trabajar con Typescript escribimos solamente: anchor init mydapp cd mydapp # Output is something like this: yarn install v1.22.17 warning package.json: No license field info No lockfile found. warning No license field [1/4] Resolving packages... warning @project-serum/anchor \u003e @solana/web3.js \u003e rpc-websockets \u003e circular-json@0.5.9: CircularJSON is in maintenance only, flatted is its successor. [2/4] Fetching packages... [3/4] Linking dependencies... warning \" \u003e ts-mocha@8.0.0\" has incorrect peer dependency \"mocha@^3.X.X || ^4.X.X || ^5.X.X || ^6.X.X || ^7.X.X || ^8.X.X\". [4/4] Building fresh packages... success Saved lockfile. Done in 11.66s. mydapp initialized Como podrás comprobar, este comando creo la siguiente estructura de archivos: tree -L 1 # Output is something like this: . ├── Anchor.toml ├── app ├── Cargo.toml ├── migrations ├── node_modules ├── package.json ├── programs ├── tests ├── tsconfig.json └── yarn.lock 5 directories, 5 files Como se puede apreciar hay cuatro directorios a resaltar: app - Este directorio se utilizará para alojar el frontend de la aplicación. programs - Aquí se alojan los programas codificados en Rust. Estos son los archivos que defines los programas sobre la blockchain de Solana. test - En este directorio de alojan las pruebas para cada unas de las funcionalidades de nuestra dapp. migrations - Contiene todos los scripts necesarios para el despliegue de la dapp. Echemos un vistazo al programa que se creó para nosotros. Anchor utiliza, y nos permite escribir, un eDSL (DSL embebido) que abstrae muchas de las operaciones de bajo nivel más complejas que normalmente tendrías que hacer si estuvieras usando Solana y Rust sin él, haciéndolo más accesible. useanchor_lang::prelude::*;declare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");#[program]pubmod mydapp{usesuper::*;pubfn initialize(ctx: Context\u003cInitialize\u003e)-\u003e ProgramResult{Ok(())}}#[derive(Accounts)]pubstruct Initialize{} Este es probablemente el programa más básico que puedes escribir. Lo único que sucede aquí es que estamos definiendo una función llamada initialize, que cuando se invoca simplemente sale del programa con éxito. No hay ninguna manipulación de datos. La estructura Initialize define el contexto como vacío de cualquier argumento. Aprenderemos más sobre el contexto de la función más adelante. Para compilar este programa, podemos ejecutar el comando Anchor build: anchor build # Output is something like this: BPF SDK: /home/alejandro/.local/share/solana/install/releases/1.8.16/solana-release/bin/sdk/bpf cargo-build-bpf child: rustup toolchain list -v cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release Compiling proc-macro2 v1.0.36 Compiling unicode-xid v0.2.2 Compiling syn v1.0.86 Compiling serde_derive v1.0.136 Compiling serde v1.0.136 Compiling version_check v0.9.4 Compiling typenum v1.15.0 Compiling serde_json v1.0.79 Compiling semver v1.0.6 Compiling anyhow v1.0.56 Compiling ryu v1.0.9 Compiling opaque-debug v0.3.0 Compiling cfg-if v1.0.0 Compiling itoa v1.0.1 Compiling yansi v0.5.0 Compiling cpufeatures v0.2.1 Compiling unicode-segmentation v1.9.0 Compiling bs58 v0.3.1 Compiling subtle v2.4.1 Compiling rustversion v1.0.6 Compiling featu","date":"2022-03-10","objectID":"/20220310solana/:5:0","tags":["Sistemas distribuidos"],"title":"Programando Dapps sobre Solana","uri":"/20220310solana/"},{"categories":["Blockchain"],"content":"Hello World Ahora que tenemos nuestro proyecto configurado, vamos a crear algo un poco más interesante. Sé que, como desarrollador full stack, la mayoría de las veces me pregunto cómo hacer operaciones del tipo CRUD, así que eso es lo que veremos a continuación. El primer programa que crearemos nos permitirá crear un contador que se incremente cada vez que lo llamemos desde una aplicación cliente. Lo primero que debemos hacer es abrir programs/mysolanaapp/src/lib.rs y actualizarlo con el siguiente código: useanchor_lang::prelude::*;declare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");#[program]mod mydapp{usesuper::*;pubfn create(ctx: Context\u003cCreate\u003e)-\u003e ProgramResult{letbase_account=\u0026mutctx.accounts.base_account;base_account.count=0;Ok(())}pubfn increment(ctx: Context\u003cIncrement\u003e)-\u003e ProgramResult{letbase_account=\u0026mutctx.accounts.base_account;base_account.count+=1;Ok(())}}// Transaction instructions #[derive(Accounts)]pubstruct Create\u003c'info\u003e{#[account(init, payer = user, space = 16 + 16)]pubbase_account: Account\u003c'info,BaseAccount\u003e,#[account(mut)]pubuser: Signer\u003c'info\u003e,pubsystem_program: Program\u003c'info,System\u003e,}// Transaction instructions #[derive(Accounts)]pubstruct Increment\u003c'info\u003e{#[account(mut)]pubbase_account: Account\u003c'info,BaseAccount\u003e,}// An account that goes inside a transaction instruction #[account]pubstruct BaseAccount{pubcount: u64,} Nota Recuerda que si estás usando Anchor 0.22.0 o superior debes remplazar ProgramResult por Result\u003c()\u003e. En este programa tenemos dos funciones - create e increment. Estas dos funciones son los manejadores de peticiones RPC que podremos llamar desde una aplicación cliente para interactuar con el programa. El primer parámetro de un manejador RPC es la estructura Context, que describe el contexto que se pasará cuando se llame a la función y cómo manejarlo. En el caso de Create, se esperan tres parámetros: base_account, user, y system_program. Los atributos #[account(…)] definen las restricciones e instrucciones que están relacionadas con la cuenta de origen donde se declara. Si alguna de estas restricciones no se mantiene, entonces la instrucción nunca se ejecutará. Cualquier cliente que llame a este programa con la base_account adecuada puede llamar a estos métodos RPC. La forma en que Solana maneja los datos es muy diferente a cualquier cosa con la que haya trabajado. No hay un estado persistente dentro del programa, todo se adjunta a lo que se conoce como cuentas. Una cuenta contiene esencialmente todo el estado de un programa. Debido a esto, todos los datos se pasan por referencia desde el exterior. Tampoco hay operaciones de lectura. Esto se debe a que todo lo que necesitas hacer para leer el contenido de un programa es solicitar la cuenta, a partir de ahí eres capaz de ver todo el estado del programa. Para leer más sobre el funcionamiento de las cuentas, consulta este post. Para construir el programa: anchor build # Output is something like this: BPF SDK: /home/alejandro/.local/share/solana/install/releases/1.8.16/solana-release/bin/sdk/bpf cargo-build-bpf child: rustup toolchain list -v cargo-build-bpf child: cargo +bpf build --target bpfel-unknown-unknown --release Compiling mydapp2 v0.1.0 (/home/alejandro/Documentos/Education/Blog/mydapp2/programs/mydapp2) Finished release [optimized] target(s) in 1.07s cargo-build-bpf child: /home/alejandro/.local/share/solana/install/releases/1.8.16/solana-release/bin/sdk/bpf/scripts/strip.sh /home/alejandro/Documentos/Education/Blog/mydapp2/target/bpfel-unknown-unknown/release/mydapp2.so /home/alejandro/Documentos/Education/Blog/mydapp2/target/deploy/mydapp2.so cargo-build-bpf child: /home/alejandro/.local/share/solana/install/releases/1.8.16/solana-release/bin/sdk/bpf/dependencies/bpf-tools/llvm/bin/llvm-readelf --dyn-symbols /home/alejandro/Documentos/Education/Blog/mydapp2/target/deploy/mydapp2.so To deploy this program: $ solana program deploy /home/alejandro/Documentos/Education/Blog/mydapp2/target/deploy/mydapp2.so The program address","date":"2022-03-10","objectID":"/20220310solana/:6:0","tags":["Sistemas distribuidos"],"title":"Programando Dapps sobre Solana","uri":"/20220310solana/"},{"categories":["Blockchain"],"content":"Construyento la React App En la raíz del proyecto Anchor, crea una nueva react app para sobrescribir el directorio de la app existente: create-react-app app El siguiente paso es instalar la dependencias que vamos a necesitar para Anchor y Solana Web3: cd app yarn add @project-serum/anchor @solana/web3.js También vamos a utilizar Solana Wallet Adapter para controlar las conexiones de la monederos de los usuarios de solana. Para esto hacemos: yarn add @solana/wallet-adapter-react @solana/wallet-adapter-react-ui @solana/wallet-adapter-wallets @solana/wallet-adapter-base A continuación, en el directorio src, crea un nuevo archivo llamado idl.json. Aquí, copie el IDL JSON que fue creado para usted en la carpeta principal del proyecto, ubicado en target/idl/mydapp.json. Sería bueno si pudiéramos copiar este archivo idl automáticamente a nuestra carpeta src de la aplicación cliente, pero hasta ahora no he encontrado una manera de hacer esto de forma nativa. Por supuesto, puedes crear tu propio script que haga esto si lo deseas, o bien necesitas copiar y pegar sobre el IDL después de cada cambio en tu programa principal. Si quieres un script como este, puedes hacerlo en sólo un par de líneas de código: //copyIdl.js const fs = require('fs'); const idl = require('./target/idl/mysolanaapp.json'); fs.writeFileSync('./app/src/idl.json', JSON.stringify(idl)); A continuación, abre app/src/App.js y actualízalo con lo siguiente: import './App.css'; import { useState } from 'react'; import { Connection, PublicKey } from '@solana/web3.js'; import { Program, Provider, web3 } from '@project-serum/anchor'; import idl from './idl.json'; import { PhantomWalletAdapter } from '@solana/wallet-adapter-wallets'; import { useWallet, WalletProvider, ConnectionProvider } from '@solana/wallet-adapter-react'; import { WalletModalProvider, WalletMultiButton } from '@solana/wallet-adapter-react-ui'; require('@solana/wallet-adapter-react-ui/styles.css'); const wallets = [ /* view list of available wallets at https://github.com/solana-labs/wallet-adapter#wallets */ new PhantomWalletAdapter() ] const { SystemProgram, Keypair } = web3; /* create an account */ const baseAccount = Keypair.generate(); const opts = { preflightCommitment: \"processed\" } const programID = new PublicKey(idl.metadata.address); function App() { const [value, setValue] = useState(null); const wallet = useWallet(); async function getProvider() { /* create the provider and return it to the caller */ /* network set to local network for now */ const network = \"http://127.0.0.1:8899\"; const connection = new Connection(network, opts.preflightCommitment); const provider = new Provider( connection, wallet, opts.preflightCommitment, ); return provider; } async function createCounter() { const provider = await getProvider() /* create the program interface combining the idl, program ID, and provider */ const program = new Program(idl, programID, provider); try { /* interact with the program via rpc */ await program.rpc.create({ accounts: { baseAccount: baseAccount.publicKey, user: provider.wallet.publicKey, systemProgram: SystemProgram.programId, }, signers: [baseAccount] }); const account = await program.account.baseAccount.fetch(baseAccount.publicKey); console.log('account: ', account); setValue(account.count.toString()); } catch (err) { console.log(\"Transaction error: \", err); } } async function increment() { const provider = await getProvider(); const program = new Program(idl, programID, provider); await program.rpc.increment({ accounts: { baseAccount: baseAccount.publicKey } }); const account = await program.account.baseAccount.fetch(baseAccount.publicKey); console.log('account: ', account); setValue(account.count.toString()); } if (!wallet.connected) { /* If the user's wallet is not connected, display connect wallet button. */ return ( \u003cdiv style={{ display: 'flex', justifyContent: 'center', marginTop:'100px' }}\u003e \u003cWalletMultiButton /\u003e \u003c/div\u003e ) } else { return ( \u003cdiv className=\"App\"\u003e \u003cdiv\u003e { !value","date":"2022-03-10","objectID":"/20220310solana/:7:0","tags":["Sistemas distribuidos"],"title":"Programando Dapps sobre Solana","uri":"/20220310solana/"},{"categories":["Blockchain"],"content":"Configurar la red local en la Wallet Antes de poder interactuar con un programa en la red localhost, debemos cambiar nuestro monedero Phantom a la red adecuada. Para ello, abre tu monedero Phantom y haz clic en el botón de configuración. A continuación, desplácese hacia abajo para cambiar la red: Figura 1. Cambiar la redred \" Figura 1. Cambiar la red A continuación, elija Localhost: Figura 2. Seleccionar la redLocalhost \" Figura 2. Seleccionar la red Ahora tenemos que enviar tokens por aire a esta cartera. En la parte superior de la interfaz del monedero, haz clic en tu dirección para copiarla en el portapapeles. Figura 3. Dirección del monederoAddress \" Figura 3. Dirección del monedero A continuación, en una termina ejecutamos el siguiente comando (asegurate que solana-test-validator esté corriendo): solana airdrop 2 «YOUR_ADDRESS» Ahora deberías tener 2 solanas en tu cartera. Ahora podemos ejecutar y probar la aplicación. Cambia al directorio de la aplicación y ejecuta el siguiente comando: yarn start Deberías poder conectar tu cartera, crear un contador e incrementarlo. Notarás que cuando refrescas, pierdes el estado del programa. Esto es porque estamos generando dinámicamente la cuenta base cuando el programa se carga. Si quieres leer e interactuar con los datos del programa a través de varios clientes, tendrías que crear y almacenar el Keypair en algún lugar de tu proyecto. He reunido una idea general de un enfoque ingenuo de cómo podría verse esto. ","date":"2022-03-10","objectID":"/20220310solana/:8:0","tags":["Sistemas distribuidos"],"title":"Programando Dapps sobre Solana","uri":"/20220310solana/"},{"categories":["Blockchain"],"content":"Despliegue en la Devnet A partir de aquí, el despliegue en una red activa es bastante sencillo. Las principales cosas que tenemos que hacer son: Actualice la CLI de Solana para utilizar devnet: solana config set --url devnet Actualizar el monedero para usar devnet. En el archivo Anchor.toml actualizar el cluster de localnet a devnet. Compilar el programa nuevamente. Asegurate que el ID del programa en Anchor.toml se igual al ID actual del programa. En archivo app/src/App.js, también es necesario actualizar la red, para esto debemos remplazar la red de localhost: http://127.0.0.1:8899 por la red de desarrollo: devnet. /* antes */ \u003cConnectionProvider endpoint=\"http://127.0.0.1:8899\"\u003e /* despues */ import { ..., clusterApiUrl } from '@solana/web3.js'; const network = clusterApiUrl('devnet'); \u003cConnectionProvider endpoint={network}\u003e A partir de aquí, deberías poder desplegar y probar como hemos hecho en los pasos anteriores. Nota El código se encuentra alojado en el github. ","date":"2022-03-10","objectID":"/20220310solana/:9:0","tags":["Sistemas distribuidos"],"title":"Programando Dapps sobre Solana","uri":"/20220310solana/"},{"categories":["Blockchain"],"content":"El siguiente paso para no parar de aprender Te sugiero continuar aprendiendo sobre NFTs sobre el proyecto de Metaplex. ","date":"2022-03-10","objectID":"/20220310solana/:10:0","tags":["Sistemas distribuidos"],"title":"Programando Dapps sobre Solana","uri":"/20220310solana/"},{"categories":["Blockchain"],"content":"Patrocinio ₿itcoin: Solana: Ethereum: Paypal: ","date":"2022-03-10","objectID":"/20220310solana/:11:0","tags":["Sistemas distribuidos"],"title":"Programando Dapps sobre Solana","uri":"/20220310solana/"},{"categories":["Blockchain"],"content":"Imágenes Unplash - 3D illustration of blocks in a blockchain WhatsApp: +917559305753 Email: shubhamdhage000@gmail.com ","date":"2022-03-10","objectID":"/20220310solana/:12:0","tags":["Sistemas distribuidos"],"title":"Programando Dapps sobre Solana","uri":"/20220310solana/"},{"categories":["Blockchain"],"content":"Referencias Julius Berner. 2021. The Modern Mathematics of deep learning. Yaser Abu-Mostafa Data. 2012 - 2015. Learning From Data. Web3.js ","date":"2022-03-10","objectID":"/20220310solana/:13:0","tags":["Sistemas distribuidos"],"title":"Programando Dapps sobre Solana","uri":"/20220310solana/"},{"categories":["Agricultura de precisión"],"content":"Una blockchain es una libro de registros de bloques de información que son almacenados secuencialmente y enlazados por métodos criptográficos a través de una red de computadores. Es más que un simple algoritmo, blockchain es una tecnología que facilita la intermediación descentralizada de datos entre los participantes.","date":"2021-07-12","objectID":"/20220312precisionagriculture/","tags":["Sistemas distribuidos"],"title":"Agricultura de precisión","uri":"/20220312precisionagriculture/"},{"categories":["Agricultura de precisión"],"content":"En esta ocasión vamos a aprender cómo monitorizar una planta empleando un bot de telegram y una raspberry pi 3 model b. Este artículo que aquí se desarrolla, busca cubrir la monitorización remota de una plata, asi como la instalación de actuadores que puedan interactuar con la misma. Todo esto controlado desde un bot desarrollado para la plataforma Telegram Messenger. Por lo tanto, el principal objetivo es desarrollar un bot que sea capaz de comunicarse con un servidor, en nuestro caso con una placa Raspberry Pi, y que sea capaz de recibir información de sensores conectados a la placa y enviar órdenes a los actuadores que interactuarán con la planta supervisada. Asimismo, se desarrollará un sistema de gestión de usuarios para permitir al administrador del bot que solo hagan uso del mismo aquellos usuarios legítimos y con los permisos que les hayan concedido. Por lo tanto, será necesario desarrollar esta capa de seguridad. Para el desarrollo de este proyecto, será necesario dominar diferentes tecnologías entre las que, inicialmente, se encuentran: Telegram Messenger: habrá que estudiar cómo se realizan bots en esta plataforma, y averiguar cómo se ponen en funcionamiento y a disposición de los usuarios. Raspberry Pi: será necesario familiarizarse con el entorno Raspberry Pi para poder llegar a usar esta placa para los fines que se ha descrito. ","date":"2021-07-12","objectID":"/20220312precisionagriculture/:0:0","tags":["Sistemas distribuidos"],"title":"Agricultura de precisión","uri":"/20220312precisionagriculture/"},{"categories":["Agricultura de precisión"],"content":"Requisitos del bot Los objetivos generales a cubrir con el bot serán los siguientes: Comprobar la temperatura de la planta. Poder ventilar la planta. Comprobar la humedad ambiental. Poder regar la planta. Controlar el acceso al bot así como los permisos que se asignan a los distintos usuarios. Poder visualizar la planta de manera remota. No obstante, para planificar el correcto desarrollo del bot, hay que pensar en los usuarios que van a utilizarlo. Para ello, se va a hacer un pequeño modelado de usuarios y se verá qué característica tendrán los mismos. Se verá también qué requisitos serán necesarios cumplir para que el bot cubra el alcance del proyecto y permita interactuar con la planta, tal y como se había planificado. Diferenciaremos entre dos tipos de usuarios: los administradores del bot y los usuarios autorizados. Los demás usuarios (usuarios no autorizados) no se tendrán en cuenta, ya que no podrán interactuar con el bot. Los usuarios autorizados podrán interactuar con la planta en función de los permisos que se les hayan asignado. Los permisos, los podrán asignar los usuarios administradores desde el propio bot, e irán desde simples consultas del estado de la planta, hasta tener el control total de la misma. Por lo tanto se ha definido: Usuarios no autorizados: no pueden interactuar con el bot. Usuarios autorizados: pueden actuar con el bot en función de sus permisos. Administradores: son usuarios autorizados con todos los permisos y pueden gestionar a los usuarios. Ahora se pasa a ver qué tipo de requisitos necesita cubrir el bot tanto en la parte del cuidado de la planta como en la gestión de usuarios que se ha comentado. Si queremos conseguir que los usuarios sean capaces de recibir toda la información de los sensores conectados a la Raspberry Pi, y poder actuar con la planta mediante los actuadores, tendresmos que cubrir una serie de requisitos funcionales básicos. Los requisitos funcionales del bot se detallarán a continuación: **Requisitos relacionados con los sensores: Ver el estado de l planta Visualizar la temperatura Visualizar la humedad Solicitar una fotografía de la planta Requisitos relacionados con los actuadores: Encender/apagar la luz Encender/apagar la ventilación Regar la planta Y en cuanto a la gestión de usuarios, será necesario gestionar estas funcionalidades: Solicitar permisos de uso Admitir usuarios que han solicitado permiso Restringir usuarios Cambiar permisos a usuarios Ahora, se va a estudiar los perfiles de usuario que se pueden crear, y qué requisitos asignar a cada uno de ellos. Usuario sin permisos, podrá: Solicitar permiso para utilizar el bot Y se definen tres tipos de usuarios con permisos: Usuario «supervisor», para supervisar la planta, podrá: Solicitar más permisos Ver estado de la planta Visualizar temperatura Visualizar humedad ambiental Usuario «jardinero», además de los anteriores permisos, podrá: Solicitar una fotografía de la planta Encender/apagar luz Encender/apagar ventilación Regar la planta Usuario «administrador», tendrá todos los permisos anteriores, así como los relativos a la gestión de usuarios. Los propios de gestión de usuarios permitirán: Conceder permisos de uso Denegar permisos de uso Ascender a un usuario a un perfil superior Degradar a un usuario a un perfil inferior Con todo esto, ya se tiene una imagen más clara de todas las acciones que permitir realizar el sistema. En base a ellas, se desarrollarán tanto las soluciones hardware como software. ","date":"2021-07-12","objectID":"/20220312precisionagriculture/:1:0","tags":["Sistemas distribuidos"],"title":"Agricultura de precisión","uri":"/20220312precisionagriculture/"},{"categories":["Agricultura de precisión"],"content":"Tecnologías Tal y como se ha definido previamente, se emplearán sensores y actuadores conec- tados directamente a la placa Raspberry Pi que, a su vez, alojará tanto el bot que se desarrollará en lenguaje Python como la base de datos necesaria para su funcionamiento. Todas estas tecnologías y las subyacentes se explican en este apartado. Se comenzará hablando del hardware, con mayor incidencia en Raspberry Pi, y des- pués se pasará al software, con mención especial para Telegram y la base de datos. ","date":"2021-07-12","objectID":"/20220312precisionagriculture/:2:0","tags":["Sistemas distribuidos"],"title":"Agricultura de precisión","uri":"/20220312precisionagriculture/"},{"categories":["Agricultura de precisión"],"content":"Hardware Raspberry Pi Raspberry Pi es un ordenador de placa reducida de bajo coste, desarrollado en Reino Unido por la fundación Raspberry Pi, con el objetivo principal de incitar tanto a niños como a adultos a que aprendan sobre ordenadores y todo lo relacionado con los mismos. La idea de desarrollar algo así surgió en 2006 cuando Eben Upton, Rob Mullins, Jack Lang y Alan Mycroft, del laboratorio de informática de la Universidad de Cambridge, constataron cómo habían cambiado los conocimientos de los niños sobre la informática. En la década de los 90, surgió mucha afición por la programación entre la juventud, pero a partir del año 2000 la tendencia fue disminuyendo y esa inquietud se dirigió, principal- mente, a la programación web, de mucho más alto nivel. La fundación Raspberry Pi surgió con un objetivo en mente: Desarrollar el uso y entendimiento de los ordenadores en los niños. Su idea es conseguir ordenadores muy baratos que permitan a los niños usarlos sin miedo, abriendo su mentalidad, y educándolos en la ética del «ábrelo y mira cómo funciona». En este proyecto se trabajará con una placa Raspberry Pi 3 modelo B. Las característi- cas de este modelo son las siguientes: *** Buscar las características Sensores y actuadores En este apartado, veremos las características de los sensores que se emplearán para monitorizar la planta. En primer lugar, se nombran todas las funciones que cubren los sensores: Medida de temperatura Medida de humedad Toma de fotografías Estas funciones se traducirán en un sensor de temperatura y humedad y una cámara web. Para el sensor de temperatura y humedad ambiental, se va a contar con el sensor DHT11. Se trata de un sensor digital de alta fiabilidad y estabilidad, por su señal digital calibrada. Se ha adquirido un sensor con placa PCB, donde va insertado para facilitar su uso. Transmisión de datos del sensor DHT11 Aunque se ha dicho que el sensor es digital, en realidad esto no es del todo correcto, ya que realmente el sensor es analógico, pero internamente se realiza la conversión a se- ñal digital, y la devuelve en una trama como la que se muestra a continuación. Como se puede ver, el primer grupo de 8 bits es la parte entera de la humedad, y el segundo la parte decimal. Lo mismo para la temperatura, donde la parte entera sería el tercer grupo, y la parte decimal el cuarto. Por último se encuentran los bits de paridad para confirmar que no hay datos corruptos. Actualmente existen librerías que recogen estas tramas y devuelven los valores en de- cimal. Una de estas librerías es Adafruit. Para poder utilizar la librería Adafruit, se deberá instalar desde su repositorio en lí- nea y, una vez hecho, ya se podrá solicitar los datos al sensor, y así recibirlos en consola *** Agregar foto Cámara web Para la toma de fotografías se va a emplear una cámara web. Se consulta en Internet el listado de cámaras compatibles con Raspberry Pi para comprobar si se tiene alguna de las listadas o, en su defecto, buscar una compatible para comprar Actuadores Para actuar con la planta, se contará con una serie de componentes para: Ventilación del invernadero Riego de la planta Iluminación del invernadero Ventilador Para llevar a cabo la ventilación del invernadero, se va a contar con un pequeño ven- tilador diseñado para refrigerar ordenadores portátiles que, debido a su tamaño, es suficiente para el cometido, y que tan solo requiere un potencial de 5 voltios para su alimen- tación. ","date":"2021-07-12","objectID":"/20220312precisionagriculture/:2:1","tags":["Sistemas distribuidos"],"title":"Agricultura de precisión","uri":"/20220312precisionagriculture/"},{"categories":["Agricultura de precisión"],"content":"Imágenes Unplash - Sunset over Limuru tea farm. ","date":"2021-07-12","objectID":"/20220312precisionagriculture/:3:0","tags":["Sistemas distribuidos"],"title":"Agricultura de precisión","uri":"/20220312precisionagriculture/"},{"categories":["Agricultura de precisión"],"content":"Referencias Julius Berner. 2021. The Modern Mathematics of deep learning. Yaser Abu-Mostafa Data. 2012 - 2015. Learning From Data. ","date":"2021-07-12","objectID":"/20220312precisionagriculture/:4:0","tags":["Sistemas distribuidos"],"title":"Agricultura de precisión","uri":"/20220312precisionagriculture/"},{"categories":["Blockchain"],"content":"Una blockchain es una libro de registros de bloques de información que son almacenados secuencialmente y enlazados por métodos criptográficos a través de una red de computadores. Es más que un simple algoritmo, blockchain es una tecnología que facilita la intermediación descentralizada de datos entre los participantes.","date":"2021-07-12","objectID":"/20220209blockchainfoundations/","tags":["Sistemas distribuidos"],"title":"Fundamentos de la tecnología Blockchain","uri":"/20220209blockchainfoundations/"},{"categories":["Blockchain"],"content":"¿Cómo aprendemos los humanos? En principio la mayoría del conocimiento humano proviene de nuestra experiencia con los objetos, es decir, aprendemos de los datos que obtenemos acerca de ellos y no a partir de algún tipo de definición matemática. Esta habilidad de aprender de los datos, nos ha resultado bastante útil, dado que existe una amplia variedad de problemas que no se pueden resolver de forma analítica. En estas situaciones los datos nos permiten encontrar soluciones empíricas, que no necesariamente explican el porqué de las cosas, pero si ofrecen resultados útiles para la práctica. Por esta razón, la capacidad de aprender a partir de los datos es una técnica de mucha importancia para todas las profesiones y disciplinas. En esta ocasión vamos a tratar brevemente los principales elementos que constituyen el problema del aprendizaje a partir de los datos, para finalmente entender un poco cómo las máquinas también pueden aprender. ","date":"2021-07-12","objectID":"/20220209blockchainfoundations/:0:0","tags":["Sistemas distribuidos"],"title":"Fundamentos de la tecnología Blockchain","uri":"/20220209blockchainfoundations/"},{"categories":["Blockchain"],"content":"El problema del aprendizaje El poder aprender a partir de los datos es un proceso que puede ser automatizado, es decir, se pueden elaborar algoritmos que realizan esta tarea. En este punto es importante entender que los algoritmos que aprenden de los datos solo tratan de encontrar la mejor solución para predecir resultados, y no necesariamente encuentran el porqué. Aquí los datos guían a los algoritmos para construir la fórmula que ofrece las mejores aplicaciones en el sentido práctico. En un sentido más matemático, el problema del aprendizaje se puede formular a partir de tres espacios medibles $\\mathcal{X}$, $\\mathcal{Y}$ y $\\mathcal{Z}$, en donde el conjunto $\\mathcal{Z}$ es un subconjunto de $\\mathcal{X} \\times \\mathcal{Y}$ que representa a una relación entre los datos de $\\mathcal{X}$ e $\\mathcal{Y}$. En principio, la tarea de aprendizaje consiste en tratar de describir la relación $\\mathcal{Z}$ a partir de una muestra de datos $S=(s_{i})_{i\\in [m]}$ y alguna función de perdida $\\mathcal{L}: \\mathcal{M}( \\mathcal{X}, \\mathcal{Y} )\\times \\mathcal{Z} \\to \\mathbb{R}$ definida sobre el producto cartesiano entre el conjunto $\\mathcal{M}( \\mathcal{X}, \\mathcal{Y} )$ de todas las funciones medibles de $\\mathcal{X}$ a $\\mathcal{Y}$ y el conjunto $\\mathcal{Z}$, y con imagen en los número reales. La función $\\mathcal{L}$ se emplea principalmente para medir cúal es el performance del aprendizaje en el algoritmo. Resolver esta tarea implica hacer la elección de un conjunto de hipótesis $\\mathcal{H} \\subset \\mathcal{M}( \\mathcal{X}, \\mathcal{Y} )$ y la construcción de un algoritmo de aprendizaje, es decir, encontrar un mapeo: \\begin{equation} \\mathcal{A}: \\bigcup_{ m\\in \\mathbb{N} } \\mathcal{Z}^{m} \\to \\mathcal{H} \\end{equation} que a partir de una muestra de datos $S = (s_i)_{i\\in[m]}$ de cierto tamaño $m$ logre encontrar un modelo $h_S = \\mathcal{A}(S)\\in \\mathcal{H}$ con «buen comportamiento» en $S$ y «capacidad de generalizar» para los datos desconocidos en $\\mathcal{Z} \\setminus \\{s_i\\}_{i\\in[m]}$. Aquí, el buen comportamiento se mide via la función de perdida $\\mathcal{L}$ y corresponde a la perdida $\\mathcal{L}(h_S, z)$, mientras la capacidad de generalizar quiere decir que el comportamiento de $h_S$ en $z\\in \\mathcal{Z} \\setminus \\{s_i\\}_{i\\in[m]}$ es similar a $z\\in \\mathcal{S}$. Creo que en este punto, estamos de acuerdo con que las nociones de «buen comportamiento» y «la capacidad de generalizar» son bastante vagas, sin embargo, veamos como mejorar estas ideas, para lograr esto vamos a centrar la atención en los conceptos de riesgo ideal y de riesgo empírico cómo veremos a continuación. El riesgo ideal de una hipótesis $h\\in \\mathcal{H}$ con respecto a la distribucción de probabilidad $\\mathcal{D}$ sobre $\\mathcal{Z}$, se define como: \\begin{equation}\\tag{1} L_{D}(h) = \\mathbb{E}_{z\\sim \\mathcal{D}}[\\mathcal{L}(h, z)]. \\end{equation} Observe que para esta definición, la esperanza de la función de perdida de $h$ es sobre los datos de $z$ muestreados aleatoriamente de acuerdo con la distribucción $\\mathcal{D}$. Hay que señalar que en la práctica la distribución $\\mathcal{D}$ es esencialmente desconocida. Por otro lado, el riesgo empírico es la perdida esperada sobre una muestra de datos $S = (s_i)_{i \\in[m]}$, es decir: \\begin{equation}\\tag{2} L_{S}(h) = \\frac{1}{m}\\sum_{i=1}^{m}\\mathcal{L}(h, s_i). \\end{equation} Ahora bien, si existiera el modelo $h^*\\in \\mathcal{H}$ tal que el riesgo ideal es cero, $L_{D}(h^*)=0$, entonces el riesgo empírico también sería cero, $L_{S}(h^*)=0$, pues el modelo no presentaría ningún error en su tarea de predicción, aunque esto es lo esperado, por lo general, no es posible encontrar un modelo con las características de $h^*$. En la práctica para encontrar el mejor modelo, los esfuerzos se centran en una muestra de datos $S = (s_i)_{i \\in[m]}$ y un conjunto de hipótesis $\\mathcal{H}$, de tal manera que el objetivo ahora es encontrar un modelo $h_s\\in \\mathcal{H}$ que satisface la siguiente cond","date":"2021-07-12","objectID":"/20220209blockchainfoundations/:1:0","tags":["Sistemas distribuidos"],"title":"Fundamentos de la tecnología Blockchain","uri":"/20220209blockchainfoundations/"},{"categories":["Blockchain"],"content":"Tareas de predicción y clasificación Veamos algunos ejemplos de problema de aprendizaje basados en datos: Clasificación Multiclase. Consideremos la tarea de clasificar documentos. Nuestro deseo es diseñar un programa con la capacidad para clasificar una colección de documentos, de acuerdo a diferentes tópicos (e.g., noticias, deportes, biología, medicina). Un algoritmo de aprendizaje para esta tarea debería tener acceso a una colección de documentos correctamente clasificados, $S$, y con base a estos ejemplos, debería entregar una programa (modelo) que puede tomar un nuevo documento y clasificarlo. Aquí el dominio, $\\mathcal{X}$, es el conjunto de todos los posibles documentos. Es importante señalar, que los documentos debería ser representados por un conjunto de características, que podría incluir el número de palabras diferentes en cada documento, el tamaño de cada documento, el autor, el origen, etc. Las etiquetas, $\\mathcal{Y}$, es el conjunto de todos los posibles tópicos (en este caso, debería ser algún conjunto finito). Una vez hemos identificado el dominio y las etiquetas, el otro componente que hace falta es determinar una función de perdida adecuada para medir el performance de nuestro algoritmo. Para el caso de la clasificación multiclase se puede considerar la variable aleatoria $z$ en $\\mathcal{X}\\times \\mathcal{Y}$ con la siguiente función de perdida: \\begin{equation} \\mathcal{L}(h, (x, y)) = \\begin{cases} 0 \\mbox{ si } h(x) = y, \\newline \\newline 1 \\mbox{ si } h(x)\\neq y. \\end{cases} \\end{equation} Esta función se usa en general para problemas de clasificación binaria o multiclase. Regresión. En esta tarea, el objetivo es encontrar algún patrón simple en los datos –una relación funcional entre los componentes de los datos $\\mathcal{X}$ e $\\mathcal{Y}$–. Por ejemplo, encontrar la mejor función que predice el peso de nacimiento de un bebe en relación con las medidas obtenidas por ultrasonido del diámetro de su cabeza, el diámetro abdominal y la longitud de su fémur. Aquí el dominio es algún subconjunto de $\\mathbb{R}^{3}$ (las tres medidas obtenidas por el ultrasonido) y las etiquetas es el conjunto de los números reales (el peso en gramos). En este caso el conjunto de entrenamiento es igual que antes, un subconjunto $S\\subseteq \\mathcal{X}\\times \\mathcal{Y}$. Sin embargo, la medida de éxito es diferente. En este ejemplo, se podría evaluar la calidad de la hipótesis $h:\\mathcal{X}\\to \\mathcal{Y}$ por el valor esperado del cuadrado de la diferencia entre las etiquetas correctas y su predicción, es decir: \\begin{equation} \\mathcal{L}(h, (x,y)) = (h(x)-y)^2. \\end{equation} ","date":"2021-07-12","objectID":"/20220209blockchainfoundations/:2:0","tags":["Sistemas distribuidos"],"title":"Fundamentos de la tecnología Blockchain","uri":"/20220209blockchainfoundations/"},{"categories":["Blockchain"],"content":"¿Cómo aprenden las maquinas? Como vimos anteriormente, el problema del aprendizaje involucra la elección de un conjunto de hipótesis $\\mathcal{H}$ y la búsqueda de la hipótesis $h_{s}$ tal que: \\begin{equation} h_s \\in \\operatorname*{argmin}_{h\\in \\mathcal{H}} L_{S}(h). \\end{equation} En otras palabras, el problema del aprendizaje se reduce a un problema de optimización del riesgo empírico $\\mathcal{L}_{S}(h)$. Para resolver este tipo de problemas existe una amplia variedad de algoritmos de optimización de funciones, en particular para estas tareas el algoritmo por excelencia es el algoritmo del descenso del gradiente, este consiste en general en realizar la siguiente iteración \\begin{equation} h \\leftarrow h - \\lambda \\nabla L_{D}(h) \\end{equation} para encontrar una hipótesis $h_s$. Este es un proceso que puede ser automatizable en casi cualquier computadora. Por lo tanto, en principio cualquier máquina con la capacidad de ejecutar este tipo de iteraciones, estaría en la capacidad de aprender a clasificar y predecir a partir de los datos. Sin embargo, hay que indicarle a la computadora cómo debe aprender, para esto se debe programar una serie de órdenes en las que se le indica como optimizar las diferentes funciones de perdida, según la tarea de aprendizaje que le deseamos enseñarle, una vez los algoritmos se haya ejecutado, la computadora debería estar en la capacidad de clasificar y predecir, obviamente esto no es una tarea sencilla, pero no es imposible. Dejaré por el momento esta publicación hasta aquí, para no hacerla más extensa, espero que la hayan disfrutado. Nos vemos pronto. ","date":"2021-07-12","objectID":"/20220209blockchainfoundations/:3:0","tags":["Sistemas distribuidos"],"title":"Fundamentos de la tecnología Blockchain","uri":"/20220209blockchainfoundations/"},{"categories":["Blockchain"],"content":"Imágenes Unplash - blockchain concept illustration in 3d, connected blocks in blockchain. 「 LOGO / BRAND / 3D design 」 WhatsApp: +917559305753 Email: shubhamdhage000@gmail.com. ","date":"2021-07-12","objectID":"/20220209blockchainfoundations/:4:0","tags":["Sistemas distribuidos"],"title":"Fundamentos de la tecnología Blockchain","uri":"/20220209blockchainfoundations/"},{"categories":["Blockchain"],"content":"Referencias Julius Berner. 2021. The Modern Mathematics of deep learning. Yaser Abu-Mostafa Data. 2012 - 2015. Learning From Data. ","date":"2021-07-12","objectID":"/20220209blockchainfoundations/:5:0","tags":["Sistemas distribuidos"],"title":"Fundamentos de la tecnología Blockchain","uri":"/20220209blockchainfoundations/"},{"categories":["Inteligencia Artificial"],"content":"¿Cómo aprendemos los humanos? En principio la mayoría del conocimiento humano proviene de nuestra experiencia con los objetos, es decir, aprendemos de los datos que obtenemos acerca de ellos y no a partir de algún tipo de definición matemática.","date":"2021-07-12","objectID":"/20210712machinelearning/","tags":["Machine Learning","Tareas de aprendizaje","Regresión","Clasificación"],"title":"Aprendiendo de los datos","uri":"/20210712machinelearning/"},{"categories":["Inteligencia Artificial"],"content":"¿Cómo aprendemos los humanos? En principio la mayoría del conocimiento humano proviene de nuestra experiencia con los objetos, es decir, aprendemos de los datos que obtenemos acerca de ellos y no a partir de algún tipo de definición matemática. Esta habilidad de aprender de los datos, nos ha resultado bastante útil, dado que existe una amplia variedad de problemas que no se pueden resolver de forma analítica. En estas situaciones los datos nos permiten encontrar soluciones empíricas, que no necesariamente explican el porqué de las cosas, pero si ofrecen resultados útiles para la práctica. Por esta razón, la capacidad de aprender a partir de los datos es una técnica de mucha importancia para todas las profesiones y disciplinas. En esta ocasión vamos a tratar brevemente los principales elementos que constituyen el problema del aprendizaje a partir de los datos, para finalmente entender un poco cómo las máquinas también pueden aprender. ","date":"2021-07-12","objectID":"/20210712machinelearning/:0:0","tags":["Machine Learning","Tareas de aprendizaje","Regresión","Clasificación"],"title":"Aprendiendo de los datos","uri":"/20210712machinelearning/"},{"categories":["Inteligencia Artificial"],"content":"El problema del aprendizaje El poder aprender a partir de los datos es un proceso que puede ser automatizado, es decir, se pueden elaborar algoritmos que realizan esta tarea. En este punto es importante entender que los algoritmos que aprenden de los datos solo tratan de encontrar la mejor solución para predecir resultados, y no necesariamente encuentran el porqué. Aquí los datos guían a los algoritmos para construir la fórmula que ofrece las mejores aplicaciones en el sentido práctico. En un sentido más matemático, el problema del aprendizaje se puede formular a partir de tres espacios medibles $\\mathcal{X}$, $\\mathcal{Y}$ y $\\mathcal{Z}$, en donde el conjunto $\\mathcal{Z}$ es un subconjunto de $\\mathcal{X} \\times \\mathcal{Y}$ que representa a una relación entre los datos de $\\mathcal{X}$ e $\\mathcal{Y}$. En principio, la tarea de aprendizaje consiste en tratar de describir la relación $\\mathcal{Z}$ a partir de una muestra de datos $S=(s_{i})_{i\\in [m]} \\in \\mathcal{Z}^{m}$ y alguna función de perdida $\\mathcal{L}: \\mathcal{M}( \\mathcal{X}, \\mathcal{Y} )\\times \\mathcal{Z} \\to \\mathbb{R}$ definida sobre el producto cartesiano entre el conjunto $\\mathcal{M}( \\mathcal{X}, \\mathcal{Y} )$ de todas las funciones medibles de $\\mathcal{X}$ a $\\mathcal{Y}$ y el conjunto $\\mathcal{Z}$, y con imagen en los número reales. La función $\\mathcal{L}$ se emplea principalmente para medir cúal es el performance del aprendizaje en el algoritmo. Resolver esta tarea implica hacer la elección de un conjunto de hipótesis $\\mathcal{H} \\subset \\mathcal{M}( \\mathcal{X}, \\mathcal{Y} )$ y la construcción de un algoritmo de aprendizaje, es decir, encontrar un mapeo: \\begin{equation} \\mathcal{A}: \\bigcup_{ m\\in \\mathbb{N} } \\mathcal{Z}^{m} \\to \\mathcal{H} \\end{equation} que a partir de una muestra de datos $S = (s_i)_{i\\in[m]}$ de cierto tamaño $m$ logre encontrar un modelo $h_S = \\mathcal{A}(S)\\in \\mathcal{H}$ con «buen comportamiento» en $S$ y «capacidad de generalizar» para los datos desconocidos en $\\mathcal{Z} \\setminus \\{s_i\\}_{i\\in[m]}$. Aquí, el buen comportamiento se mide via la función de perdida $\\mathcal{L}$ y corresponde a la perdida $\\mathcal{L}(h_S, z)$, mientras la capacidad de generalizar quiere decir que el comportamiento de $h_S$ en $z\\in \\mathcal{Z} \\setminus \\{s_i\\}_{i\\in[m]}$ es similar a $z\\in \\mathcal{S}$. Creo que en este punto, estamos de acuerdo con que las nociones de «buen comportamiento» y «la capacidad de generalizar» son bastante vagas, sin embargo, veamos como mejorar estas ideas, para lograr esto vamos a centrar la atención en los conceptos de riesgo ideal y de riesgo empírico cómo veremos a continuación. El riesgo ideal de una hipótesis $h\\in \\mathcal{H}$ con respecto a la distribucción de probabilidad $\\mathcal{D}$ sobre $\\mathcal{Z}$, se define como: \\begin{equation}\\tag{1} L_{D}(h) = \\mathbb{E}_{z\\sim \\mathcal{D}}[\\mathcal{L}(h, z)]. \\end{equation} Observe que para esta definición, la esperanza de la función de perdida de $h$ es sobre los datos de $z$ muestreados aleatoriamente de acuerdo con la distribucción $\\mathcal{D}$. Hay que señalar que en la práctica la distribución $\\mathcal{D}$ es esencialmente desconocida. Por otro lado, el riesgo empírico es la perdida esperada sobre una muestra de datos $S = (s_i)_{i \\in[m]}$, es decir: \\begin{equation}\\tag{2} L_{S}(h) = \\frac{1}{m}\\sum_{i=1}^{m}\\mathcal{L}(h, s_i). \\end{equation} Ahora bien, si existiera el modelo $h^*\\in \\mathcal{H}$ tal que el riesgo ideal es cero, $L_{D}(h^*)=0$, entonces el riesgo empírico también sería cero, $L_{S}(h^*)=0$, pues el modelo no presentaría ningún error en su tarea de predicción, aunque esto es lo esperado, por lo general, no es posible encontrar un modelo con las características de $h^*$. En la práctica para encontrar el mejor modelo, los esfuerzos se centran en una muestra de datos $S = (s_i)_{i \\in[m]}$ y un conjunto de hipótesis $\\mathcal{H}$, de tal manera que el objetivo ahora es encontrar un modelo $h_s\\in \\mathcal{H}$ que satisfa","date":"2021-07-12","objectID":"/20210712machinelearning/:1:0","tags":["Machine Learning","Tareas de aprendizaje","Regresión","Clasificación"],"title":"Aprendiendo de los datos","uri":"/20210712machinelearning/"},{"categories":["Inteligencia Artificial"],"content":"Tareas de predicción y clasificación Veamos algunos ejemplos de problema de aprendizaje basados en datos: Clasificación Multiclase. Consideremos la tarea de clasificar documentos. Nuestro deseo es diseñar un programa con la capacidad para clasificar una colección de documentos, de acuerdo a diferentes tópicos (e.g., noticias, deportes, biología, medicina). Un algoritmo de aprendizaje para esta tarea debería tener acceso a una colección de documentos correctamente clasificados, $S$, y con base a estos ejemplos, debería entregar una programa (modelo) que puede tomar un nuevo documento y clasificarlo. Aquí el dominio, $\\mathcal{X}$, es el conjunto de todos los posibles documentos. Es importante señalar, que los documentos debería ser representados por un conjunto de características, que podría incluir el número de palabras diferentes en cada documento, el tamaño de cada documento, el autor, el origen, etc. Las etiquetas, $\\mathcal{Y}$, es el conjunto de todos los posibles tópicos (en este caso, debería ser algún conjunto finito). Una vez hemos identificado el dominio y las etiquetas, el otro componente que hace falta es determinar una función de perdida adecuada para medir el performance de nuestro algoritmo. Para el caso de la clasificación multiclase se puede considerar la variable aleatoria $z$ en $\\mathcal{X}\\times \\mathcal{Y}$ con la siguiente función de perdida: \\begin{equation} \\mathcal{L}(h, (x, y)) = \\begin{cases} 0 \\mbox{ si } h(x) = y, \\newline \\newline 1 \\mbox{ si } h(x)\\neq y. \\end{cases} \\end{equation} Esta función se usa en general para problemas de clasificación binaria o multiclase. Regresión. En esta tarea, el objetivo es encontrar algún patrón simple en los datos –una relación funcional entre los componentes de los datos $\\mathcal{X}$ e $\\mathcal{Y}$–. Por ejemplo, encontrar la mejor función que predice el peso de nacimiento de un bebe en relación con las medidas obtenidas por ultrasonido del diámetro de su cabeza, el diámetro abdominal y la longitud de su fémur. Aquí el dominio es algún subconjunto de $\\mathbb{R}^{3}$ (las tres medidas obtenidas por el ultrasonido) y las etiquetas es el conjunto de los números reales (el peso en gramos). En este caso el conjunto de entrenamiento es igual que antes, un subconjunto $S\\subseteq \\mathcal{X}\\times \\mathcal{Y}$. Sin embargo, la medida de éxito es diferente. En este ejemplo, se podría evaluar la calidad de la hipótesis $h:\\mathcal{X}\\to \\mathcal{Y}$ por el valor esperado del cuadrado de la diferencia entre las etiquetas correctas y su predicción, es decir: \\begin{equation} \\mathcal{L}(h, (x,y)) = (h(x)-y)^2. \\end{equation} ","date":"2021-07-12","objectID":"/20210712machinelearning/:2:0","tags":["Machine Learning","Tareas de aprendizaje","Regresión","Clasificación"],"title":"Aprendiendo de los datos","uri":"/20210712machinelearning/"},{"categories":["Inteligencia Artificial"],"content":"¿Cómo aprenden las maquinas? Como vimos anteriormente, el problema del aprendizaje involucra la elección de un conjunto de hipótesis $\\mathcal{H}$ y la búsqueda de la hipótesis $h_{s}$ tal que: \\begin{equation} h_s \\in \\operatorname*{argmin}_{h\\in \\mathcal{H}} L_{S}(h). \\end{equation} En otras palabras, el problema del aprendizaje se reduce a un problema de optimización del riesgo empírico $\\mathcal{L}_{S}(h)$. Para resolver este tipo de problemas existe una amplia variedad de algoritmos de optimización de funciones, en particular para estas tareas el algoritmo por excelencia es el algoritmo del descenso del gradiente, este consiste en general en realizar la siguiente iteración \\begin{equation} h \\leftarrow h - \\lambda \\nabla L_{D}(h) \\end{equation} para encontrar una hipótesis $h_s$. Este es un proceso que puede ser automatizable en casi cualquier computadora. Por lo tanto, en principio cualquier máquina con la capacidad de ejecutar este tipo de iteraciones, estaría en la capacidad de aprender a clasificar y predecir a partir de los datos. Sin embargo, hay que indicarle a la computadora cómo debe aprender, para esto se debe programar una serie de órdenes en las que se le indica como optimizar las diferentes funciones de perdida, según la tarea de aprendizaje que le deseamos enseñarle, una vez los algoritmos se haya ejecutado, la computadora debería estar en la capacidad de clasificar y predecir, obviamente esto no es una tarea sencilla, pero no es imposible. Dejaré por el momento esta publicación hasta aquí, para no hacerla más extensa, espero que la hayan disfrutado. Nos vemos pronto. ","date":"2021-07-12","objectID":"/20210712machinelearning/:3:0","tags":["Machine Learning","Tareas de aprendizaje","Regresión","Clasificación"],"title":"Aprendiendo de los datos","uri":"/20210712machinelearning/"},{"categories":["Inteligencia Artificial"],"content":"Referencias Julius Berner. 2021. The Modern Mathematics of deep learning. Yaser Abu-Mostafa Data. 2012 - 2015. Learning From Data. ","date":"2021-07-12","objectID":"/20210712machinelearning/:4:0","tags":["Machine Learning","Tareas de aprendizaje","Regresión","Clasificación"],"title":"Aprendiendo de los datos","uri":"/20210712machinelearning/"},{"categories":["Inteligencia Artificial"],"content":"¿Cómo aprendemos los humanos? En principio la mayoría del conocimiento humano proviene de nuestra experiencia con los objetos, es decir, aprendemos de los datos que obtenemos acerca de ellos y no a partir de algún tipo de definición matemática.","date":"2022-02-10","objectID":"/20200212svd/","tags":["Machine Learning","Tareas de aprendizaje","Regresión","Clasificación"],"title":"Descomposición matricial por valores singulares (SVD)","uri":"/20200212svd/"},{"categories":["Inteligencia Artificial"],"content":"En esta ocasión vamos a introducir la descomposición por valores singulares (SVD por sus siglas en inglés) y cómo aplicar la SVD mediante ejemplos prácticos desarrollados en Python, Rust y C++. Es importante entender la SVD porque es el fundamento otras técnicas de aprendizaje mecánico, como lo es los métodos de clasificación, la descomposición dinámica (DMD) y la descomposición ortogonal propia (POD). La alta dimensionalidad es un reto común en el procesamiento de datos que proviene de sistemas complejos. Por ejemplo con datos que provienes de fuentes de audio, video o imagenes. Los datos también puede ser generados por sistemas físicos, como lo es el registros de interacciones neuronales de un cerebro, o la registros de velocidad de una simulación del movimiento de un fluido o experimento.Es natural que en la mayoría de los sistemas, los datos exhiban patrones dominantes, que pueden ser caracterizados por atractores o variedades de dimensionalidad baja. La SVD provee una forma sistemática para determinar una aproximación de baja dimensionalidad a un conjunto de datos de alta dimensionalidad en términos de los patrones dominantes. Esta técnica «direcciona los datos» en descubrir esos patrones propiamente de los datos, si recurrir al conocimiento del experto de los datos o la intuición. La SVD es numéricamente estable y provee una representación herarquica de los datos en términos de un nuevo sistema de coordenadas definido por las correlaciones dominantes en los datos. Además, la SVD existe para cualquier matriz, lo que la diferencias de la descomposición por valores propios. La SVD tiene aplicaciones muy importantes que van más allá de la reducción de dimensionalidad de datos de alta dimensionalidad. Es usada para calcular las psudo-inversa de matrices no cuadradas, proporcionando soluciones a sisteamas de ecuaciones matriciales infradeterminadas o sobredeterminadas, $\\pmb{A}x=b$. La SVD también se emplea para la reducción de ruido en conjunto de datos. La SVD también es igual de importante para caracterizar la geometria de entrada y salida de una transformación lineal entre espacios vectoriales. (Agregar referencias). ","date":"2022-02-10","objectID":"/20200212svd/:0:0","tags":["Machine Learning","Tareas de aprendizaje","Regresión","Clasificación"],"title":"Descomposición matricial por valores singulares (SVD)","uri":"/20200212svd/"},{"categories":["Inteligencia Artificial"],"content":"Definición de la SVD En general, el objetivo es analizar un conjunto de datos con la estructura $X\\in \\mathcal{C}^{n\\times m}$: \\begin{equation} X=\\begin{pmatrix} | \u0026 | \u0026 \u0026 | \\\\ x_1 \u0026 x_2 \u0026 \\cdots \u0026 x_m \\\\ | \u0026 | \u0026 \u0026 | \\\\ \\end{pmatrix}. \\end{equation} La columnas $x_k\\in \\mathcal{C}^{n}$ puede ser medidas de una simulación o resultados de un experimento. Por ejemplo, las columnas puede representar imagenes que han sido reorganizadas en vectores columnas en donde cada entrada es un pixel en la imagen. El indice $k$ es una etiqueta que indica el registro $k$-ésimo de las medidas. En muchas ocasiones, $X$ consiste de una serie de datos, de tal forma que $x_k =x(k\\delta t)$. Con frecuencia de la dimensión $n$ es muy grande, en un orden de un millón o billones de grados de libertad. La columna amenudo se denomina registros, y $m$ es el número de registros en $X$. Para muchos sistemas $n\\gg m$, resultando en una matrix tall-skinny, que es opuesta a una matriz short-fat cuando $n\\ll m$. La SVD es una descomposición matricial única que existe para todas las matrices $X\\in \\mathcal{C}^{n\\times m}$: \\begin{equation} X= U\\Sigma V^{*} \\end{equation} donde $U\\in \\mathcal{C}^{n\\times n}$ y $V\\in \\mathcal{C}^{m\\times m}$ son matrices unitarias con columnas ortonormales, y $\\Sigma \\in \\mathcal{R}^{n\\times m}$ es una matriz con entradas reales, no negativas en la diagonal principal y cero en fuera de ella. Aquí $^*$ denota la transposición de matrices complejas. Cuando $n\\geq m$, la matriz $\\Sigma$ tiene al menos $m$ elementos no nulos sobre la diagonal principal, así que la matriz $\\Sigma$ se puede escribir como $\\Sigma = \\begin{bmatrix} \\hat{\\Sigma} \\\\ 0 \\end{bmatrix}$. Por lo tanto, una representación exacta de $X$ usando la descomposición económica de SVD: \\begin{equation} X=U\\Sigma V^{*} = \\begin{bmatrix} \\hat{U} \u0026 \\hat{U}^{\\perp}\\end{bmatrix}\\begin{bmatrix}\\hat{\\Sigma} \\\\ 0 \\end{bmatrix} V^{*} = \\hat{U}\\hat{\\Sigma} V^{*}. \\end{equation} La decomposición completa SVD y la decomposición económica SVD se ilustran en la figura (xxx). Las columnas de $\\hat{U}^{\\perp}$ generan el espacio vectorial que es complementario y ortogonal al espacio generado por $\\hat{U}$. Las columnas de $U$ se denominan vectores singulares a izquierda de $X$ y las columnas de $V$ son los vectores singulares a derecha. Los elementos de la diagonal de $\\hat{Sigma}\\in \\mathcal{C}^{m\\times m}$ se denominan valores propios y son ordenados de de mayor a menor. El rango de $X$ es igual al número de valores singulares no nulos. ","date":"2022-02-10","objectID":"/20200212svd/:1:0","tags":["Machine Learning","Tareas de aprendizaje","Regresión","Clasificación"],"title":"Descomposición matricial por valores singulares (SVD)","uri":"/20200212svd/"},{"categories":["Inteligencia Artificial"],"content":"Calculando la descomposición SVD La descomposición SVD es la piedra angular de la ciencia computacional y la ingeniería. Su implementación númerica es importante y matemáticamente esclarecedora. Dicho esto, la mayoría de las implementaciones númericas están desarrolladas e implementadas con una interfaz simple en la mayoría de los lenguajes de programación modernos, lo que nos permite abstraer los detalles computacionales que hay detrás de la descomposición SVD. Para la mayoría de los propositos, nosotros vamos a asumir que SVD proviene ya de un esfuerzo colectivo mayor y que por lo tanto ya viene garantizada la existencia de eficiencia y estabilidad de los algoritmos que vamos a emplear. A continuación, vamos a ilustrar como usar la descomposición SVD en varios lenguajes de programación. ","date":"2022-02-10","objectID":"/20200212svd/:2:0","tags":["Machine Learning","Tareas de aprendizaje","Regresión","Clasificación"],"title":"Descomposición matricial por valores singulares (SVD)","uri":"/20200212svd/"},{"categories":["Inteligencia Artificial"],"content":"SVD con Python import numpy as np # Create radom data matrix X = np.random.rand(5, 3) # full SVD U, S, V = np.linalg.svd(X, full_matrices=True) # economy SVD U_hat, S_hat, V_hat = np.linalg.svd(X, full_matrices=False) ","date":"2022-02-10","objectID":"/20200212svd/:2:1","tags":["Machine Learning","Tareas de aprendizaje","Regresión","Clasificación"],"title":"Descomposición matricial por valores singulares (SVD)","uri":"/20200212svd/"},{"categories":["Inteligencia Artificial"],"content":"Otros lenguajes La descomposición SVD también está disponible en otros lenguajes, como Fortran, C++, Rust, R, Julia. En efecto, la mayoría de las implementaciones de SVD se basan en LAPACK en Fortran. La rutina de SVD se designa como DGESVD en LAPACK, y esto está envuelto en las librerías Armadillo y Eigen de C++. ","date":"2022-02-10","objectID":"/20200212svd/:2:2","tags":["Machine Learning","Tareas de aprendizaje","Regresión","Clasificación"],"title":"Descomposición matricial por valores singulares (SVD)","uri":"/20200212svd/"},{"categories":["Inteligencia Artificial"],"content":"Referencias Julius Berner. 2021. The Modern Mathematics of deep learning. Yaser Abu-Mostafa Data. 2012 - 2015. Learning From Data. ","date":"2022-02-10","objectID":"/20200212svd/:3:0","tags":["Machine Learning","Tareas de aprendizaje","Regresión","Clasificación"],"title":"Descomposición matricial por valores singulares (SVD)","uri":"/20200212svd/"}]